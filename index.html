<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>Othello&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Othello's Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Othello's Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Othello's Blog">
  
    <link rel="alternative" href="/atom.xml" title="Othello&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="https://avatars2.githubusercontent.com/u/18623875?v=3&amp;s=466" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">晨曦的葬歌</a></h1>
		</hgroup>

		
		<p class="header-subtitle">天上半阴半暗的云</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主 页</a></li>
	        
				<li><a href="/archives">归 档</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/TheSongOfDawn" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/u/3943183234?refer_flag=1001030101_" title="weibo">weibo</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/li-ke-19-67" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">晨曦的葬歌</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="https://avatars2.githubusercontent.com/u/18623875?v=3&amp;s=466" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">晨曦的葬歌</h1>
			</hgroup>
			
			<p class="header-subtitle">天上半阴半暗的云</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主 页</a></li>
		        
					<li><a href="/archives">归 档</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/TheSongOfDawn" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/3943183234?refer_flag=1001030101_" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/li-ke-19-67" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-基于Unity引擎的游戏开发基础-课程笔记3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/12/基于Unity引擎的游戏开发基础-课程笔记3/">基于Unity引擎的游戏开发基础-课程笔记3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>//还没有调整格式<br>//今天晚上写了一道bfs 没写出来。太容易沉迷其中不能脱身用大局观看这种东西。费脑子也费时间！！！阿西吧</p>
<p>第二周学习是C#基础。因为我有编程基础且本学期正在学习这门语言，故跳过。但要学习脚本必须要有C#的基础知识！补上了再看脚本！</p>
<p>Unity脚本基本概念</p>
<p>交互是游戏开发中必不可少的概念，它使玩家能根据自己的意愿改变游戏场景中的某些元素与行为<br>交互包括玩家通过输入系统与游戏场景进行互动，也包括游戏场景中游戏对象之间的交互<br>开发者实现游戏交互功能的主要手段，实现交互的主要工具就是脚本 （Script）</p>
<p>在 Project 视图中 点击鼠标右键，选择 Create 菜单下面的 C# 即可完成脚本的创建 </p>
<p>根据脚本的实际功能 将脚本绑定到场景中与脚本相关的游戏对象 绑定前的脚本作为游戏资源保存在项目目录下，绑定后的脚本成为该游戏对象的组件</p>
<p>Unity 编辑器中创建的脚本 都默认继承了 MonoBehaviour 类，并带有 MonoBehaviour 类中的定义的两个 Unity 事件函数 Start 和 Update</p>
<p>修改 Unity 脚本默认开发工具的流程 首先点击 Edit 菜单栏中的 Preferences，打开 Unity Preferences 窗口 接着点击 Unity Preferences 窗口中的外部工具标签 将外部编辑工具改为 Visual Studio 2015<br>在 Unity 脚本中使用 Debug.Log Debug.LogWarning、 Debug.LogError 等函数 在控制台输出我们所需要的脚本调试信息</p>
<p>Console（控制台）视图</p>
<p>Clear 点击将删除控制台当前所有信息<br>Collapse 按钮起用时。相同的信息在控制台只显示一次（消息尾部显示它出现的次数）<br>Clear On play 在每次游戏预览时，Unity 清除控制台显示的所有消息<br>Error Pause 按钮，在游戏预览过程中，如果脚本出现错误 Unity 中断本次游戏预览</p>
<p>脚本生命周期：<br>初始化阶段：<br>1.Awake() 在脚本绑定到的游戏对象激活时执行 这里需要注意：即使包含 Awake 函数的脚本组已禁用状态 该脚本中的 Awake 函数也会被 Unity 调用<br>2.OnEnable() 当对象变为可用或激活状态时 该函数执行一次<br>3.Start () 第一次Update之前调用；Start 在每个场景中只执行一次，如果在场景中已经执行过 Start 函数 即使 OnEnable 函数再次执行，Start 函数也不会执行<br>循环阶段:<br>4.FixedUpdate 固定更新<br>物理循环，物理循环用于处理游戏中与物理相关的逻辑 FixedUpdate 函数是物理循环中最先执行的函数 它每隔固定时间执行一次，我们通常与把物理模拟有关的代码 写在 FixedUpdate 函数中</p>
<p>5.OnTrigger 函数，它用于 Trigger 触发器检测 每隔固定时间检测一次。 触发器检测函数包括 OnTriggerEnter，OnTriggerStay，OnTriggerExit 当物体进入，停留，离开 Trigger 触发器范围时执行</p>
<p>6.OnCollision 碰撞检测函数 它用于 Collider 碰撞体的相关检测，每隔固定时间检测一次。 碰撞检测函数包括 OnCollisionEnter OnCollisionStay，OnCollisionExit，当物体进入，停- 留，离开 Collider 碰撞体范围时执行 OnTrigger 函数与 OnCollision 函数通常用于与碰撞检测有关的游戏逻辑</p>
<ol>
<li>OnMouse 函数，处理鼠标的输入事件</li>
</ol>
<p>游戏逻辑循环<br>7.Update 函数 它在每帧执行一次，该函数主要处理游戏对象在游戏世界的行为逻辑 例如游戏角色的控制和游戏状态的控制<br>8.LateUpdate 函数，它也是每帧执行一次，在 Update 函数后执行。 在实际开发过程中 Update 函数与 LateUpdate 函数通常共同使用，例如在第三人称射击游戏中 我们在 Update 函数中处理玩家角色的移动，在 LateUpdate 函数中处理摄像机跟随玩家 这样能防止摄像机出现抖动现象。</p>
<p>游戏逻辑循环结束后<br>9.OnGUI 渲染和处理GUI事件 用到NGUI插件<br>OnGUI 函数每帧可执行多次，用于绘制 Unity 的图形用户界面</p>
<p>在脚本被禁用前，Unity 循环调用物理循环到游戏循环到OnGUI()函数 实现游戏对象的正常更新<br>脚本被禁用时，Unity跳出循环调用</p>
<p>10.OnDisable 当前对象不可用或非激活状态时被调用等待命令。若重新启用脚本 脚本将从 OnDisable 函数跳转至 OnEnable 函数 跳转完成后，脚本按照生命周期中函数执行顺序 循环运行，直到下一次脚本被禁用<br>当脚本 被解除绑定时调用<br>11.OnDestory 被销毁时调用<br>脚本的生命周期结束</p>
<p>Unity脚本之间的执行顺序</p>
<p>Unity脚本之间默认执行顺序，以堆栈的方式，先设置，后执行。也就是说最先绑定的脚本最后执行</p>
<p>使用MonoManager对脚本的执行顺序进行排序：<br>MonoManager的打开方式：<br>打开 Edit 菜单，点击 Project Setting 中的 Script Execution Order，即可打开 MonoManager</p>
<p>使用 MonoManager 管理脚本之间的执行顺序<br>首先点击右下方的加号按钮添加 Unity 脚本，其次修改脚本的优先级 该值越小，脚本越早执行。 若把脚本的优先级设置为 0，脚本将在 Default Time 执行 该脚本从列表中消失。 最后点击 Apply 按钮，应用设置。</p>
<p>注意：<br>1.如果脚本没有在 MonoManager 中设置优先级，表明脚本的优先级为 0 脚本在 Default Time 缺省时间执行<br>2.对优先级相等的脚本 采用默认的执行顺序为：最先设置的脚本最后执行<br>3.优先级只表示脚本执行顺序的前后 并不表示脚本执行时间的延迟，例如优先级 = 100，不表示脚本执行延迟 100 毫秒 </p>
<p>在《多米诺骨牌》项目中 实现了大球自转 摄像机围绕金字塔公转<br>实现大球自转需要两个参数，<br>自转的旋转轴<br>每帧的旋转角度<br>摄像机围绕金字塔公转需要四个参数<br>摄像机公转的旋转中心<br>公转的旋转轴<br> 每帧旋转角度<br>摄像机的朝向</p>
<p>在脚本中设置为公有字段的可以方便我们在Inspector视图中对该字段进行修改</p>
<p>实现大球自转脚本代码如下</p>
<p>public class SelfRotate : MonoBehaviour {</p>
<pre><code>public float rotateSpeed = 40.0f;    //旋转速度  可以在Inspector视图中修改
</code></pre><p>//若脚本中参数的初始值与 Inspector 视图中的设定的值不相等 则以 Inspector 视图中的设定值为准</p>
<pre><code>//每帧执行一次：物体自转
void Update () {
    //物体以世界坐标系的向上方向（正Y轴）方向，以rotateSpeed的速度进行顺时针自转
    //Time.deltaTime表示该帧的执行时间，Time.deltaTime * rotateSpeed表示该帧总共自转的角度
    transform.Rotate (Vector3.up, Time.deltaTime * rotateSpeed);    
}
</code></pre><p>}</p>
<p>transform Rotate 函数实现，该函数需要三个参数 第一个参数是旋转轴向量。 将它设置为 Vector3 的 up 方向，让大球围绕 up 方向，也就是 y 轴进行自转 第二个参数是旋转角度 设置为 Time.deltaTime*rotateSpeed 表示大球在每帧围绕 up 方面的旋转角度 第三个参数是旋转参照系的选择 该参数的缺省值为物体自身的参照系，我们不需要传入这个参数</p>
<p>摄像机围绕金字塔公转脚本：</p>
<p>public class RotateAroundAndLookAt : MonoBehaviour {</p>
<pre><code>public GameObject rotateCenter;        //旋转中心对象
public float rotateSpeed = 10.0f;    //旋转速度

//每帧执行一次：物体公转
void Update () {
    if (rotateCenter) {        //当旋转中心对象设置时才进行物体公转
        transform.RotateAround (    
            rotateCenter.transform.position,    //旋转中心点
            rotateCenter.transform.up,             //旋转轴：此处设置为为旋转中心的向上方向（正Y轴）
            Time.deltaTime * rotateSpeed        //旋转的角度，rotateSpeed表示旋转的速度，Time.deltaTime表示该帧执行的时间
        );
        transform.LookAt(rotateCenter.transform);    //使游戏对象始终朝向旋转中心
    }
}
</code></pre><p>}</p>
<p>otate Around 函数 该函数有三个参数，分别是公转的旋转中心 旋转轴向量和旋转角度。<br> 公转的旋转中心坐标设置为 rotateCenter.transform.position 该字段表示旋转中心的位置坐标 旋转轴向量设置为 rotateCenter.transform.up 该字段表示旋转中心的 y 轴正方向 旋转角度设置为 Time.deltaTime*rotateSpeed 该字段表示摄像机在每帧旋转的角度。 最后我们使用 transform 类的 LookAt 函数 以 rotateCenter.transform 作为函数的参数，使摄像机始终朝向旋转中心 最后，把 RotateAroundAndLookAt 脚本 绑定到摄像机游戏对象，并在 Inspector 视图中把参数 rotateCenter 设置为 Hierarchy 视图中的 Top 对象</p>
<p>如何实现骨牌相撞时发出声音？<br>1.如何控制撞击音效的播放时机<br>2.如何播放撞击音效</p>
<p>该脚本代码实现了多米诺骨牌之间相互撞击时播放撞击音效文件</p>
<p>public class DominoCollide : MonoBehaviour {</p>
<pre><code>//当有物体与该物体即将发生碰撞时，调用OnCollisionEnter()函数
void OnCollisionEnter(Collision collision)    
{
    if (collision.gameObject.tag.Equals(&quot;Domino&quot;))    //根据碰撞物体的标签来判断该物体是否为多米诺骨牌
        GetComponent&lt;AudioSource&gt;().Play();            //获取多米诺骨牌撞击音效的AudioSource组件并播放
}
</code></pre><p>}</p>
<p>如何给大球添加力？<br>如何添加力？<br>如何时刻保持力的作用？</p>
<p>public class ObjectAddForce : MonoBehaviour {</p>
<pre><code>public int force;    //作用力大小

//每隔固定时间执行一次，用于物理模拟
void FixedUpdate () {
    gameObject.GetComponent&lt;Rigidbody&gt;()        //获取游戏对象上的刚体组件
        .AddForce (new Vector3(0,-force,0));    //给刚体添加方向向下的作用力
}
</code></pre><p>}</p>
<p> ObjectAddForce 类中，字段 force 表示作用力的大小 使用 public 修饰符。 在FixedUpdate 函数内首先获取物体的刚体组件 在调用刚体组件的 AddForce 函数完成作用力的添加 Addforce 函数需要两个参数 第一个参数为力向量，用以表示作用力的大小与方向 第二个参数为力的模式，缺省表示持续作用力</p>
<p>多米诺骨牌中的摄像机切换<br> 如何检测S键是否按下<br> 如何切换摄像机</p>
<p>public class CameraSwitch : MonoBehaviour {</p>
<pre><code>public Camera mainCamera;    //主摄像机
public Camera orthCamera;    //正交摄像机

//摄像机状态初始化
void Start(){
    mainCamera.enabled = true;    //启用主摄像机
    orthCamera.enabled = false;    //禁用正交摄像机
}

//每帧调用一次：摄像机切换
void Update () {
    if (Input.GetKeyDown(KeyCode.S)){    //当玩家按下键盘上的“S”键时
        mainCamera.enabled = !mainCamera.enabled;    //切换主摄像机的启用与禁用状态
        orthCamera.enabled = !orthCamera.enabled;    //切换正交摄像机的启用与禁用状态
    }
}
</code></pre><p>}</p>
<p>地形系统（Terrain）<br>5*5</p>
<p>Unity拥有功能强大且完善的地形编辑器 支持以笔刷的方式，实时绘制多种地形 同时，还提供地表绘制元素，制作树木、 草坪、 石头等地表元素</p>
<p>地形创建的步骤</p>
<p>在 Hierarchy 视图中，点击鼠标右键 在弹出的菜单中选择 3D Object 中的 Terrain，完成地形创建</p>
<p>地形系统的相关组件<br>Transform 组件：<br>更改 Position 属性可以更改地形系统在场景中的位置，而修改 Rotation 与 Scale 属性，并不影响地图系统的朝向与尺寸</p>
<p>Terrain 组件<br>地形编辑工具<br>该组件包含七个按钮，前六个按钮用于实时编辑地形效果 第七个按钮表示该地形系统的属性设置</p>
<p>Terrain Collider 组件<br>该组件表示地形的碰撞体，在创建地形体统 时，会在 Project 视图中自动生成一个地形系统碰撞体 并自动应用到 Terrain Data 属性中 地形系统碰撞体的形状，会根据地形的实时编辑发生改变 </p>
<p>地形系统编辑工具</p>
<p>Raise/Lower Terrain（升高/降低地形）<br>启用该 按钮，按住鼠标左键拖动，可以升高地形高度，绘制出山脉 按住 shift 键，并按住鼠标左键拖动，可以降低地形高度 绘制出峡谷。 地形高度为 0 时，不再降低<br>相关参数：<br> Brushes，表示绘制地形高度的笔刷样式 Brush Size，表示笔刷尺寸，取值范围为 1 到 100 Opacity 表示绘制强度 用于确定每次点击后地形升高或降低的强度 取值范围为 0 到 100 </p>
<p>Paint Height（喷涂高度）<br>用于将地形绘制到指定高度<br>启用该按钮，按住鼠标 左键拖动，可以改变地形高度，直到地形高度达到指定值<br>相关参数：<br>Height 表示地形指定的高度 点击 Flatten 按钮，可以将整个地形绘制到指定的高度</p>
<p>Smooth Height （平滑高度）<br>点击 Terrain 组件的第三个按钮，打开平滑高度工具 首先可以选择笔刷的样式，并设定大小和强度 然后在地形上拖动鼠标左键，即可提高地形的平滑度 </p>
<p>Paint Texture （绘制纹理）<br>用于绘制地表的纹理<br>启用该按钮，每次点击鼠标左键 进行该区域的纹理绘制。 我们可以点击 Edit Texture 进行纹理设置 第一次添加的纹理会自动应用到整个地形系统 后续添加的纹理将通过笔刷的形式实现绘制</p>
<p>相关参数：<br>Target Strength 表示纹理绘制的最大影响程度 数值 0 表示纹理绘制完全没有影响 数字 1 表示纹理绘制将完全覆盖之前的纹理图像</p>
<p>Place Tree（种植树）<br>用于在地形上添加树模型 在种植树之前需要添加树的模型</p>
<p>树模型的设置步骤：<br>点击 Add Tree 按钮，即可以执行树模型的添加、 编辑 移除操作，选中树模型，选 Mass Place Trees 按钮 可以在整个地形系统中随机种植树木<br>随机种植树的几个相关的参数<br>Number Of Trees，表示随机种植树的个数<br>Keep Existing Trees 选项表示的是是否保留以种植的树<br>设置完成后，点击 Place 按钮 可以在整个地形系统上完成树的随机种植<br>该工具的相关参数<br>Tree Density 表示树绘制的密度，<br>Tree Height，表示绘制的树高度 可以选择随机的范围。<br>Lock Width to Height，确定树的宽高比是否一致<br> Tree Width，表示绘制的树宽度 可以选择随机范围，<br>当 Lock Width to Height 属性不勾选时，可以编辑该属性<br>Random Tree Rotate，用于确定树的朝向是否随机</p>
<p>Paint Detail（绘制细节）<br> 用于在地形上添加草等 在绘制细节之前，需要设置细节的纹理或网格</p>
<p>细节的设置步骤<br>点击 Add Detail，开始细节的编辑，分为 Grass Texture 和 Detail Mesh 两种 Grass Texture 用于草纹理的设置，Detail Mesh 用于细节网格的设置</p>
<p>Terrain Setting （地形设置）<br>用于设置地形系统的相关参数<br>Base Terrain，表示地形系统的基本参数设置<br>其中 Draw 表示是否呈现地形系统<br> Pixel Error 表示像素容差，显示地形网格时允许的像素误差<br> Base Map Dist，用于设置高分辨率地形贴图的显示范围。为了提高效率，与摄像机距离超过该值的纹理，将以较低的分辨率显示<br>Cast Shadows，表示该地形是否投射阴影<br>Tree &amp; Detail Objects 表示树和细节的相关参数的设置，其中 Draw 表示是否呈现树 和细节，<br>Detail Distance 用于设置超过摄像机多少距离的细节 将会停止渲染，<br>Tree Distance 表示树的显示距离 树与摄像机距离超过 Tree Distance，不对树进行渲染<br> Resolution，表示地形系统的分辨率设置 其中 Terrain Width 表示地形系统的宽度，Terrain Length 表示地形系统的长度，Terrain Height，表示地形系统的高度</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/04/12/基于Unity引擎的游戏开发基础-课程笔记3/" class="archive-article-date">
  	<time datetime="2017-04-12T14:47:50.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-04-12</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/">Unity</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-基于Unity引擎的游戏开发基础-课程笔记2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/12/基于Unity引擎的游戏开发基础-课程笔记2/">基于Unity引擎的游戏开发基础-课程笔记2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="图形资源分类"><a href="#图形资源分类" class="headerlink" title="图形资源分类"></a>图形资源分类</h4><p>简单地可以分为2D和3D</p>
<p>图形 2D 图形是平面图形，只有长宽两个维度。 三维图形是立体图形 拥有长宽高三个维度。</p>
<p>2D 图形在计算机中有两种表示形式：位图与矢量 位图图像通常称为点阵图像 它是由多个单点的像素组成的，每个像素具有 RGBA 颜色值 所有像素按照矩形进行排列，构成一幅图像 我们用 扫描仪、 手机、 照相机，拍摄获得的照片都是位图</p>
<p>矢量图 矢量图也称为面向对象的图像，或者叫绘图图像 在数学上面可以定义为一系列的点，点之间以线作为连接 矢量文件中的图形元素称为对象 每个对象都是一个自成一体的实体 具有颜色、 形状、 轮廓、 大小和屏幕位置等属性<br>与位图不同，矢量图在放大过程中不会失真 不会出现颗粒感。 矢量图的显示效果与分辨率无关</p>
<h4 id="游戏对象-（GameObject）"><a href="#游戏对象-（GameObject）" class="headerlink" title="游戏对象 （GameObject）"></a>游戏对象 （GameObject）</h4><p>游戏场景中存在的物体都可以称为游戏对象。游戏对象是一个非常广泛的概念，场景中的物体环境元素 特效都是一个游戏对象</p>
<h4 id="标签-tag"><a href="#标签-tag" class="headerlink" title="标签(tag)"></a>标签(tag)</h4><p>游戏对象标签可以方便我们区分一些特殊种类的游戏对象</p>
<h4 id="组件-Component"><a href="#组件-Component" class="headerlink" title="组件(Component)"></a>组件(Component)</h4><p> 在游戏场景中，游戏对象之间的表现与行为差异。Unity使用组件来表示游戏对象的某种属性或行为</p>
<h4 id="Transform组件"><a href="#Transform组件" class="headerlink" title="Transform组件"></a>Transform组件</h4><p>用于设置游戏对象在场景中的位置 朝向以及尺寸<br>绝大部分游戏对象（UI游戏对象除外）都包含Transform组件<br>Transformz组件无法手动添加或删除，创建游戏对象时自带的组件</p>
<ul>
<li>Position：游戏对象相对于其父对象的坐标位置</li>
<li>Rotation：游戏对象相对于其父对象的x y z轴的旋转角度（顺时针为正）</li>
<li>Scale 游戏对象相对于其父对象的x y z轴方向的缩放倍数 1表示原始长度</li>
</ul>
<p>父子关系与Transform组件 当游戏对象称为另一个游戏对象的子对象，该游戏对象的Transform组件会发生改变</p>
<h4 id="预制件（prefab）"><a href="#预制件（prefab）" class="headerlink" title="预制件（prefab）"></a>预制件（prefab）</h4><p>预制件（prefab）是一种资源类型 存储在Project（项目）视图中的游戏对象原型。预制件可以多次放入到多个场景中。当你拖拽一个预制件到场景中，就在该场景中创建了该预制件的一个实例。所有的预制件实例连接到原始预制件。当你对预制件进行任何更改·这些改动都会自动应用于所有预制件实例</p>
<h4 id="物理系统基础"><a href="#物理系统基础" class="headerlink" title="物理系统基础"></a>物理系统基础</h4><p>物理系统 ：在虚拟世界中使用物理引擎，运用物理算法对游戏对象的运动进行模拟，例如重力 摩擦力 碰撞等 ，让游戏更加真实</p>
<h4 id="物理系统组件"><a href="#物理系统组件" class="headerlink" title="物理系统组件"></a>物理系统组件</h4><ul>
<li>刚体（Rigidbody）</li>
<li>恒定力（Constant Force）</li>
<li>碰撞体（Collider）</li>
</ul>
<h4 id="物理系统管理器（Physics-Manager）"><a href="#物理系统管理器（Physics-Manager）" class="headerlink" title="物理系统管理器（Physics Manager）"></a>物理系统管理器（Physics Manager）</h4><ul>
<li><p>刚体（Rigidbody）是物理学中一个重要的概念，它是指一个物体在受力的情况下 其外形 尺寸 内部结构组织等都不受影响的一个特性<br>在Unity中，刚体用于模拟世界中物体受力之后的行为.每个游戏对象只能添加一个刚体组件。</p>
</li>
<li><p>Mass表示对象的质量</p>
</li>
<li>Drag对象运动时的阻力 </li>
<li>Angular Drag对象旋转时的角阻力</li>
<li>Use Gravity：是否应用重力（默认勾选应用重力）</li>
<li>Constraints 表示刚体约束</li>
<li>freeze position 表示位置约束 选择x项表示刚体受力后沿X轴不发生位移</li>
<li>Freeze Rotation 表示旋转约束 勾选x项 表示刚体受力后绕x轴不发生旋转</li>
</ul>
<h4 id="碰撞体（Collider）"><a href="#碰撞体（Collider）" class="headerlink" title="碰撞体（Collider）"></a>碰撞体（Collider）</h4><p>碰撞体定义了对象在物理系统中的碰撞形状，对象的碰撞形状用于物理模拟中的碰撞检测。当两个物体都有碰撞体组件时，物理引擎才会计算碰撞，否则物体会相互穿过。Unity中的内置对象 （Cube，Sphere）都默认添加了缺省形状的碰撞体组件，若无特殊要求我们不需要为其添加新的碰撞体组件</p>
<p>碰撞体的常用属性<br>（以球型碰撞体举例）</p>
<ul>
<li>Edit Collider ：碰撞体形状编辑按钮，点击后可在Scene（场景）视图中编辑碰撞体的形状</li>
<li>is Trigger：该碰撞体是否为触发器（默认不勾选，不是触发器）用于检测是否有物体进入该触发器的区域。碰撞体变成触发器以后，不再具有碰撞体的功能 </li>
<li>Material：碰撞体的物理材质（设置游戏对象受力后的相应）</li>
</ul>
<p>碰撞体形状尺寸设置：</p>
<ul>
<li>Center：球型碰撞体的球心位置</li>
<li>Radius：球型碰撞体的半径</li>
</ul>
<p>碰撞体勾选</p>
<ul>
<li>Is Trigger属性后会变成触发器<br>*一个物体可以拥有多个碰撞体</li>
</ul>
<h4 id="物理材质（Physic-Material）："><a href="#物理材质（Physic-Material）：" class="headerlink" title="物理材质（Physic Material）："></a>物理材质（Physic Material）：</h4><ul>
<li>Dynamic Friction：动摩擦力</li>
<li>Static Friction：静摩擦力</li>
<li>Bounciness:弹力<br>*Friction/Bounce Combine:定义两个碰撞体之间的摩擦力/弹力如何相互作用</li>
</ul>
<h4 id="物理系统管理器-（PhysicsManager）"><a href="#物理系统管理器-（PhysicsManager）" class="headerlink" title="物理系统管理器 （PhysicsManager）"></a>物理系统管理器 （PhysicsManager）</h4><ul>
<li>Gravity：设置物理系统中的重力</li>
<li>Default Material：碰撞体组件默认使用的物理材质</li>
<li>Bounce Threshold：弹性阈值</li>
<li>Default Contact Offset ：两个对象发生碰撞的距离，即当两个对象的距离小于该距离时才会发生碰撞</li>
</ul>
<h4 id="网格（Mesh）"><a href="#网格（Mesh）" class="headerlink" title="网格（Mesh）"></a>网格（Mesh）</h4><p>游戏中三维物体使用网格来描述自身的形状和尺寸。一个模型由若干网格面组成，每一个面由若干个三角形组成</p>
<p>在计算机图形学中 经常使用三角形网格来描述物体的几何信息，可以采用图形卡GPU对三角形网格有关的计算进行加速</p>
<h4 id="网格过滤器（Mesh-Filter）"><a href="#网格过滤器（Mesh-Filter）" class="headerlink" title="网格过滤器（Mesh Filter）"></a>网格过滤器（Mesh Filter）</h4><p>网格过滤器（Mesh Filter）存放游戏对象的网格信息，并把网格信息传递到网络渲染器中，最后将网格渲染到屏幕中。此组件的目的主要用于确定模型的形状与尺寸<br>网络渲染器（Mesh Renderer）</p>
<h4 id="网络渲染器（Mesh-Renderer）"><a href="#网络渲染器（Mesh-Renderer）" class="headerlink" title="网络渲染器（Mesh Renderer）"></a>网络渲染器（Mesh Renderer）</h4><p>从网格过滤器中获取几何形状，用于渲染场景中的模型</p>
<p>网格过滤器与网格过滤器必须成对使用，缺少任意一个都会导致游戏对象的渲染失败。我们可以将网格过滤器看做一个人的骨骼，把网格渲染器看做一个人的血肉。前者决定了游戏对象的几何形状，后者决定了游戏对象的外貌，颜色等表面特质</p>
<h4 id="材质Material"><a href="#材质Material" class="headerlink" title="材质Material"></a>材质Material</h4><p>网格只绘制物体的形状与尺寸，物体表面的颜色，质感特性则需要用材质Material来呈现，材质在物体的网格渲染器中设置。我们可以创建自己的材质<br>材质编辑包括 着色器（Shader）的选择 着色器的相关属性设置 Inspector视图下方有材质预览</p>
<h4 id="着色器（Shader）"><a href="#着色器（Shader）" class="headerlink" title="着色器（Shader）"></a>着色器（Shader）</h4><p>着色器主要用于图像的渲染过程，它具有可编辑性，不受显卡的固定渲染管线限制，可以实现丰富的图像效果。这极大的提高了图像的品质<br>我们可以使用着色器语言来编写相应的着色器脚本，以实现图像渲染的不同效果</p>
<h4 id="标准着色器（Standard-Shader）"><a href="#标准着色器（Standard-Shader）" class="headerlink" title="标准着色器（Standard Shader）"></a>标准着色器（Standard Shader）</h4><p>对于大多数表面效果的渲染（包括人物，风景，环境等），Unity内置的标准着色器（Standard Shader）通常是最好的选择。标准着色器是一个高度可定制的着色器，它能够呈现多种类型的表面效果<br>参数设定：</p>
<ul>
<li>REndering Mode 预设值</li>
<li>Opaque ，不透明</li>
<li>Transparent 透明效果</li>
<li>Fade 淡入淡出的效果</li>
<li><p>cutout 透明与不透明效果</p>
</li>
<li><p>Albedo：表示光的反照率 描述物体的基本颜色</p>
</li>
<li>NormalMap：法向贴图，可以通过改变光的反射角度，使物体显得凹凸不平</li>
<li>Emission：自发光 使得物体看起来“自发光”</li>
</ul>
<h4 id="天空盒（Skybox）"><a href="#天空盒（Skybox）" class="headerlink" title="天空盒（Skybox）"></a>天空盒（Skybox）</h4><p>除了标准着色器外，天空盒也是一种常用的着色器类型。它用于设置场景中的天空背景图案<br>Skybox/6 sided：一种常用的天空盒类型，其通常由x+ x- y+ y- z+ z-六个方向的贴图构成</p>
<h4 id="光源（Light）"><a href="#光源（Light）" class="headerlink" title="光源（Light）"></a>光源（Light）</h4><p>光源是场景的重要组成部分，它决定了场景的明暗，色彩和氛围<br>Light组件 ：type 光源类型 Color：光源颜色 Intensity 光照强度 Bounce Intensity ：反射光强度</p>
<h4 id="光源类型-用途"><a href="#光源类型-用途" class="headerlink" title="光源类型 用途"></a>光源类型 用途</h4><ul>
<li>方向光（Directional）：模拟极远处的光照，如地球上的太阳光</li>
<li>点光源（Point）：模拟光源向四周发出均匀的光线，例如生活中的灯泡</li>
<li>聚光灯（Spot）：模拟光源向某方向发出圆锥体光线，例如手电筒 路灯</li>
<li>面光源（Area）：无法模拟实时光照，用于光照烘焙 </li>
</ul>
<h4 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h4><p>除了光源对象外，场景中还存在环境光，环境光奠定了一个场景的基本色调。环境光的效果在Lighting视图中设置</p>
<h4 id="环境光来源："><a href="#环境光来源：" class="headerlink" title="环境光来源："></a>环境光来源：</h4><ul>
<li>天空盒（Skybox） 若Skybox材质设置，使用该材质所产生的光效果；若Skybox没有选定材质，效果同单色光（Color）</li>
<li>梯度光（Gradient） 拥有Sky，Equator，Ground三个颜色参数，分别对应天空 赤道 地面的光颜色，两两之间光颜色呈梯度分布</li>
<li>单色光（Color）根据选定的颜色作为环境光颜色</li>
</ul>
<h4 id="摄像机（Camera）"><a href="#摄像机（Camera）" class="headerlink" title="摄像机（Camera）"></a>摄像机（Camera）</h4><p>在Unity场景中，必须有一个摄像机用于绘制场景。引擎对摄像机可以看到的游戏世界中的空间区域进行渲染，生成最终的游戏画面。</p>
<p>场景中可以存在多个摄像机：<br>单人模式中只有一个摄像机 多人游戏中有两个摄像机同时渲染画面</p>
<h4 id="摄像机组件"><a href="#摄像机组件" class="headerlink" title="摄像机组件"></a>摄像机组件</h4><ul>
<li>Insector（检视）视图中的摄像机组件 Clear Flags：摄像机清除标记</li>
<li>projection：摄像机投射方式</li>
<li>Field of view：摄像机视角</li>
<li>Clipping Planes：摄像机远近剪切平面</li>
<li><p>Depth：摄像机深度值</p>
<p>清除标记用于填充屏幕中摄像机未绘制的部分（四个可选类）：</p>
</li>
<li><p>Skybox （预设） 以天空盒作为摄像机的清除标记</p>
</li>
<li>Solid Color 以某种颜色作为摄像机的 清除标记</li>
<li>Depth Only 以深度值较低的摄像机渲染的图案作为该摄像机的清除标记（用于多个摄像机的同时绘制）</li>
<li>Dont Clear 不清除，摄像机的清楚标记为上次渲染过的图像</li>
</ul>
<p>Projection（摄像机投影方式）</p>
<ul>
<li>Perspective 透视，在该模式下，摄像机显示的场景画面为我们日常生活中所看到的远小近大现象</li>
<li>Orthograhic 正交，在该模式下，场景中的物体大小不会因为与摄像机的距离不同而发生大小变化 </li>
</ul>
<p>摄像机其他组件</p>
<p><em>　GUI Layer：GUI（Unity4.6之前的旧版）显示组件，使摄像机中能够显示旧版GUI控件
</em>　Flare Layer：镜头耀斑显示组件，使镜头耀斑特效显示在摄像机所渲染的图形中<br>*　Audio Listener：音频监听组件，用于收集游戏场景中的声音并播放 </p>
<h4 id="音频（Audio）"><a href="#音频（Audio）" class="headerlink" title="音频（Audio）"></a>音频（Audio）</h4><p>音频在游戏中的地位至关重要，它给游戏添加视觉效果。优质恰当的音频使得场景更加生动</p>
<p>Unity中的音频系统通过Audio Source，音频源组件和Audio Listener音频监听组件实现</p>
<p>音频源组件用于场景中声音的播放<br>AudioListener，音频监听组件收集场景中发出的声音并播放</p>
<p>如果场景中存在多个音频监听组件，Unity编辑器会随机选择其中的一个音频监听组件生效 其余的音频监听组件均保持静默<br>Unity摄像机对象默认添加了AudioListener组件，<br>inspector视图中音频源组件</p>
<ul>
<li>AudioClip<br>表示音频片段，是音频源组件播放的音频资源 Mute保持音频源播放时是否静音，默认不勾选，表示不静音 Play On Awake表示是否在该音频源组件启动时，自动播放音频片段 默认勾选，表示自动播放；Loop，表示音频源是否循环播放音频片段<br>默认不勾选，表示不循环。 Volume 表示音频片段播放时声音的大小；Pitch，表示音频片段播放时音调的高低 </li>
</ul>
<p>音频系统管理器，AudioManager<br>音频系统管理器管理整个项目中音频系统的相关参数</p>
<p>Edit菜单栏 点击Project<br>Settings中的Audio选项，即可在inspector视图中显示项目的音频系- 统管理器<br>部分参数，Global Volume表示项目的全局音量大小 Disable Unity<br>Audio表示是否使用Unity的音频系统，默认不勾选，即使用Unity的音频系统</p>
<h4 id="项目构建（Build）"><a href="#项目构建（Build）" class="headerlink" title="项目构建（Build）"></a>项目构建（Build）</h4><p>当Unity项目制作完毕，需要对Unity项目进行构建，才能使项目脱离Unity编辑器独立运行。<br>项目构建：File菜单栏-》Build Setting<br>项目构建参数：</p>
<ol>
<li>把场景添加到构建列表<br> 打开需要构建的场景<br> 点击Add Current按钮</li>
<li>选择项目发布的平台<br> 名字后面带有Unity图标的平台表示当前项目所在的平台<br>ps：切换平台：<br>选中项目发布的平台 点击Switch Platform按钮，即可完成项目平台的切换工作</li>
<li>设置平台参数</li>
</ol>
<p>点击player Setting即可设置参数：</p>
<ol>
<li>分辨率与演示设置</li>
<li>项目图标设置</li>
<li>项目启动图像设置</li>
<li>其他设置</li>
<li>生成游戏项目</li>
<li>点击Build即可生成</li>
</ol>
<p>在进行Android平台的项目构建时，需：</p>
<p>1.Android SDK与JDK的下载设置<br>在完成SDK与JDK的下载后 需要在Unity编辑器中，Unity Preference(Edit-&gt;Preference)点击<br>Extends Tools把JDK与SDK目录设置即可<br>2.Android项目参数设置<br>player Setting 中进行 Default Orientation 设置屏幕默认朝向</p>
<p>Status Bar Hidden选项用于隐藏Android 手机的状态栏</p>
<p>Other Sittings需要设置 Identification中的Bundle Identifier该属性表示Android应用的标识符，用于区别该Android应用与其他Android应用 默认为com.Company.ProductName</p>
<p>《多米诺骨牌》项目总结</p>
<p>1.　Unity编辑器基础操作<br>    包括项目的创建，资源的导入，以及游戏对象的创建<br>2.　物理操作系统基础<br>    模拟真实世界的重力 碰撞效果<br>3.　图形系统基础<br>    给场景添加视觉效果<br>4.　音频基础<br>    给场景添加声音效果<br>5.　项目部署<br>    部署到Windows平台与安卓平台独立于Unity编辑器独立运行</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/04/12/基于Unity引擎的游戏开发基础-课程笔记2/" class="archive-article-date">
  	<time datetime="2017-04-12T03:55:09.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-04-12</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/">Unity</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-基于Unity引擎的游戏开发基础-课程笔记1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/10/基于Unity引擎的游戏开发基础-课程笔记1/">基于Unity引擎的游戏开发基础-课程笔记1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="初始"><a href="#初始" class="headerlink" title="初始"></a>初始</h3><pre><code>开始学习Unity时，在知乎上查看了Unity话题内的内容，于是准备先找课去上。本来第一个准备在Coursera上看的无奈寝室的网连视频加载不出来，退而求其次在慕课网上去找。听的基础课程真的是乱的一匹。怒开一波vpn上Coursera的课。讲真，课程讲的超级细致，非常适合初学者。非常感谢复旦大学的老师和学长们录制的这门基础课！
</code></pre><p>//本文档为Coursera 基于Unity引擎的游戏开发基础个人笔记.</p>
<h3 id="游戏引擎功能模块："><a href="#游戏引擎功能模块：" class="headerlink" title="游戏引擎功能模块："></a>游戏引擎功能模块：</h3><ul>
<li>游戏中实时光影绘制</li>
<li>动画系统 </li>
<li>物理模拟系统</li>
<li>游戏场景渲染机制</li>
<li>网络通信 AI系统</li>
<li>平台移植功能</li>
</ul>
<h3 id="Unity编辑器界面介绍："><a href="#Unity编辑器界面介绍：" class="headerlink" title="Unity编辑器界面介绍："></a>Unity编辑器界面介绍：</h3><ol>
<li><p>Project（项目）视图</p>
<p> Project视图是整个项目的资源汇总，包含了游戏项目中的场景 模型 材质 脚本 外部导入的网络模型等所有资源文件</p>
</li>
<li><p>Hierarchy（层级）视图</p>
<p> ierarchy（层级）视图包含了当前场景中所有的游戏对象</p>
</li>
<li><p>Inspector（检视）视图</p>
<p> Inspector（检视）视图用于显示当前选定的游戏对象的详细信息，包括游戏对象的名称，标签，几何属性以及其他组件信息，也可用于显示Edit菜单栏中与项目相关的参数设置</p>
</li>
<li><p>Scene（场景）视图<br> Scene（场景）视图用于显示场景中所有模型，光源，摄像机，材质，音效等游戏对象。在场景视图中，可以通过可视化的方式对场景中的游戏对象进行编辑</p>
</li>
</ol>
<h3 id="Unity编辑器菜单栏："><a href="#Unity编辑器菜单栏：" class="headerlink" title="Unity编辑器菜单栏："></a>Unity编辑器菜单栏：</h3><ul>
<li>File（文件）菜单 主要包含项目与场景的创建 保存及输出等功能</li>
<li>Edit（编辑）菜单 主要包括对场景进行一系列的编辑及环境设置操作等命令</li>
<li><p>Asset（资源）菜单 主要用于对项目视图中的资源进行管理  在Project视图中点击右键打开相似的Asset菜单</p>
</li>
<li><p>GameObject（游戏对象）菜单 对层级视图中的游戏对象进行管理</p>
</li>
<li>Component(组件)菜单 管理选中游戏对象的组件</li>
<li>Window（窗口）菜单 包含各种窗口的切换 布局等操作 还可以通过它打开各种视图以及访问Asset Store资源商店</li>
<li>Help（帮助）菜单 包含Unitu用户手册与脚本参考菜单项，能够帮助开发者学习和掌握Unity</li>
</ul>
<h3 id="Transform-Tools（变化工具）"><a href="#Transform-Tools（变化工具）" class="headerlink" title="Transform Tools（变化工具）"></a>Transform Tools（变化工具）</h3><p>（菜单栏下面的五个按钮）</p>
<ul>
<li>手型工具：用于整体平移Scene视图</li>
<li>移动工具：对选中的对象进行平移操作</li>
<li>旋转工具：对选中的对象进行旋转操作</li>
<li>缩放工具：对选中的对象进行缩放操作</li>
<li>二维缩放工具：对二维物体和uGUI进行缩放</li>
</ul>
<h3 id="Transform-Gizmo-Tools（辅助变换工具）"><a href="#Transform-Gizmo-Tools（辅助变换工具）" class="headerlink" title="Transform Gizmo Tools（辅助变换工具）"></a>Transform Gizmo Tools（辅助变换工具）</h3><p>（Center-Global）</p>
<p>游戏对象的轴心点设置：</p>
<pre><code>Center:以所有选中游戏对象的中心为轴心点；
Pivot：以最后一个选中游戏对象的中心为轴心点（ps：枢轴; 中心点，中枢; [物] 支点，支枢;）
</code></pre><p>游戏对象坐标的显示方式</p>
<pre><code>Global：以全局坐标显示游戏对象坐标；
Local：以自身坐标显示游戏对象坐标
</code></pre><h3 id="Play（播放控制）"><a href="#Play（播放控制）" class="headerlink" title="Play（播放控制）"></a>Play（播放控制）</h3><p> 播放/暂停/逐帧播放<br>运行游戏按钮：控制游戏的运行与结束，Game视图实时地显示游戏的运行效果<br>暂停游戏按钮：暂停/继续游戏 控制游戏的暂停与继续运行；<br>逐帧播放按钮：逐帧播放游戏，主要用于开发者逐帧调试游戏项目</p>
<h3 id="Layers（分层下拉列表）"><a href="#Layers（分层下拉列表）" class="headerlink" title="Layers（分层下拉列表）"></a>Layers（分层下拉列表）</h3><p>Layers（分层下拉列表）用于控制Scene视图中游戏对象的显示，睁眼符号表示属于该层的游戏对象在场景中可见，闭眼表示不可见</p>
<h3 id="Layout（布局下拉列表）"><a href="#Layout（布局下拉列表）" class="headerlink" title="Layout（布局下拉列表）"></a>Layout（布局下拉列表）</h3><p>Layout（布局下拉列表）控制Unity编辑器包含的多个视图布局方式，支持用户自定义布局</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/04/10/基于Unity引擎的游戏开发基础-课程笔记1/" class="archive-article-date">
  	<time datetime="2017-04-10T14:24:16.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-04-10</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/">Unity</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-博弈论最后一章摘录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/09/博弈论最后一章摘录/">博弈论最后一章摘录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>拖了很久，终于要记录下自己觉得迄今为止学到的比较好的的处事规则，一报还一报。</p>
<p>“一报还一报”的4大特点</p>
<ol>
<li>它是善良的（不树敌）</li>
<li>它是可激怒的（防背叛）</li>
<li>它是宽容的（给机会）</li>
<li>它是清晰的（易辨识） </li>
</ol>
<p>“针锋相对”的善良性防止他陷入非合作的麻烦中，对对方背叛的报复则保证了对方背叛行为的谨慎性，宽容性则有助于在对方背叛后重新开始合作，而简单清晰的规则则易于被人理解，从而导出长期的合作。</p>
<p>由此老师给的四点忠告：</p>
<ol>
<li>不要嫉妒</li>
<li>不要首先背叛</li>
<li>对合作和背叛都要给于回报（as soon as possible）</li>
<li>不要耍小聪明 </li>
</ol>
<p>和两点启示：</p>
<ol>
<li>合作的基础不是信任，而是关系的持续性。</li>
<li>组织相对于个人而言往往具有更长的预期寿命，<br>从而提高了关系的持续性。</li>
</ol>
<p>希望我持着这把钝剑勇敢地前行，虽然此生可能不会有大富大贵，但要从长远的目光来看，我只是后人前行的跳板，所以，踏实前行即可。</p>
<p>还记得老师在博弈论第一节课提到的：</p>
<p>知人者智，自知者明</p>
<p>胜人者力，自胜者强</p>
<p>小胜者术，大胜者强</p>
<p>留着回味。</p>
<p>博弈，必须学会换位思考，只需领人一步，高人一筹，两筹多了。<br>博弈。博：博览全局；弈：对弈棋局。讲究 谋定而动 ！ 博弈亦可以是竞争，也可以是合作。<br>博弈的最高境界也即是合作！</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/03/09/博弈论最后一章摘录/" class="archive-article-date">
  	<time datetime="2017-03-09T14:17:26.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-03-09</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/杂记/">杂记</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-慕课程序与算法设计-二" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/15/慕课程序与算法设计-二/">慕课程序与算法设计(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><pre><code>基于逐个尝试答案的一种问题求解策略
</code></pre><h3 id="例题1-完美立方"><a href="#例题1-完美立方" class="headerlink" title="例题1 完美立方"></a>例题1 完美立方</h3><pre><code>#include &lt;iostream&gt;  
using namespace std;  

int main()  
{  
    int N;
    cin&gt;&gt;N;
    for(int a=2;a&lt;=N;a++){
        for(int b=2;b&lt;a-1;b++){
            for(int c=b;c&lt;a-1;c++){
                for(int d=c;d&lt;a-1;d++){
                    if(a*a*a==(b*b*b+c*c*c+d*d*d))
                        cout&lt;&lt;&quot;Cube = &quot;&lt;&lt;a&lt;&lt;&quot;,Triple = (&quot;&lt;&lt;b&lt;&lt;&quot;,&quot;&lt;&lt;c&lt;&lt;&quot;,&quot;&lt;&lt;d&lt;&lt;&quot;)&quot;&lt;&lt;endl; 
                }
            }
        }
    } 
    return 0;
}
</code></pre><h3 id="例题2-生理周期"><a href="#例题2-生理周期" class="headerlink" title="例题2 生理周期"></a>例题2 生理周期</h3><pre><code>#include &lt;iostream&gt;  
#include &lt;cstdio&gt;
using namespace std;  
#define N 21252
int main()  
{  
    //体力 情感 智力高峰出现的日子
    // d是给定的日子 
    //caseNo表示第几组测试用例 
    int p,e,i,d,caseNo=0;
    while(cin&gt;&gt;p&gt;&gt;e&gt;&gt;i&gt;&gt;d&amp;&amp;p!=-1){
        caseNo++;
        int k;
        for(k=d+1;(k-p)%23;k++);
        for(;(k-e)%28;k+=23);
        for(;(k-i)%33;k+=23*28);
        cout&lt;&lt;&quot;Case &quot;&lt;&lt;caseNo&lt;&lt;
            &quot;:the next triple peak occurs in &quot;&lt;&lt;
            k-d&lt;&lt;&quot;days.&quot;&lt;&lt;endl; 
    }
    return 0;
}
</code></pre><h3 id="POJ103称硬币"><a href="#POJ103称硬币" class="headerlink" title="POJ103称硬币"></a>POJ103称硬币</h3><p>思路：对于每一枚硬币先假设它是轻的，看这样是否符合称量结果。如果符合，则问题解决。如果不符合，则假设它是重的，看是否符合称量结果。把所有硬币都试一遍，一定能找到特殊硬币。</p>
<h2 id="递归-一"><a href="#递归-一" class="headerlink" title="递归(一)"></a>递归(一)</h2><pre><code>递归的作用：
1. 替代多重循环
2. 解决本来就是用递归形式定义的问题
3. 将问题分解为更小规模的子问题进行求解
</code></pre><h3 id="例题1-求阶乘"><a href="#例题1-求阶乘" class="headerlink" title="例题1 求阶乘"></a>例题1 求阶乘</h3><pre><code>#include &lt;iostream&gt;  
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt; 
#include &lt;algorithm&gt;
using namespace std;  
int Factorial(int n){
    if(n==0)
        return 1;
    else
        return n*Factorial(n-1); 
} 
int main()  
{  
    int n;
    cin&gt;&gt;n;
    cout&lt;&lt;Factorial(n)&lt;&lt;endl;
    return 0;
}
</code></pre><h3 id="例题2-汉诺塔问题"><a href="#例题2-汉诺塔问题" class="headerlink" title="例题2 汉诺塔问题"></a>例题2 汉诺塔问题</h3><pre><code>#include &lt;iostream&gt;  
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt; 
#include &lt;algorithm&gt;
using namespace std;  
void Hanoi(int n,char src,char mid , char dest){
    if(n==1){//只需移动一个盘子 
        cout&lt;&lt;src&lt;&lt;&quot;-&gt;&quot;&lt;&lt;dest&lt;&lt;endl;
        //直接将盘子从src移动到dest即可
        return;//递归终止 
    }
    Hanoi(n-1,src,dest,mid);//先将n-1个盘子从src移动到mid
    cout&lt;&lt;src&lt;&lt;&quot;-&gt;&quot;&lt;&lt;dest&lt;&lt;endl;
    //再将一个盘子从src移动到dest 
    Hanoi(n-1,mid,src,dest);//最后将n-1个盘子移动到dest
    return; 

}
int main()  
{  
    int n;
    cin&gt;&gt;n;
    Hanoi(n,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;); 
    return 0;
}
</code></pre><h3 id="例题3-N皇后问题"><a href="#例题3-N皇后问题" class="headerlink" title="例题3 N皇后问题"></a>例题3 N皇后问题</h3><h3 id="例题4-逆波兰表达式求值"><a href="#例题4-逆波兰表达式求值" class="headerlink" title="例题4 逆波兰表达式求值"></a>例题4 逆波兰表达式求值</h3><p>逆波兰表达式的定义：</p>
<ol>
<li>一个数是逆波兰表达式，值为该数</li>
<li>“运算符 逆波兰表达式 逆波兰表达式 ”是逆波兰表达式，值为两个逆波兰表达式的值的运算结果</li>
</ol>
<pre><code>#include &lt;iostream&gt;  
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt; 
#include &lt;algorithm&gt;
using namespace std;  

double exp(){
    char s[20];
    cin&gt;&gt;s;
    switch(s[0]){
        case &apos;+&apos;: return exp()+exp();break;
        case &apos;-&apos;: return exp()-exp();break;
        case &apos;*&apos;: return exp()*exp();break;
        case &apos;/&apos;: return exp()/exp();break;
        default: return atof(s);break;
        //atof 头文件 &lt;cstdlib&gt; 将字符串浮点数转化为double 
    }
}
int main()  
{  
    printf(&quot;%lf&quot;,exp()); 
    return 0;
}
</code></pre><h2 id="递归-二"><a href="#递归-二" class="headerlink" title="递归(二)"></a>递归(二)</h2><h3 id="例题1-表达式求值"><a href="#例题1-表达式求值" class="headerlink" title="例题1 表达式求值"></a>例题1 表达式求值</h3><pre><code>#include &lt;iostream&gt;  
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt; 
using namespace std;  
int factor_value();//读入一个因子
int term_value();//读入一项
int expression_value();//读入表达式 
int main()  
{  
    cout&lt;&lt;expression_value()&lt;&lt;endl;
    return 0;
}
int expression_value(){
    int result=term_value();//求一项的值
    bool more=true;//还有没有其他项
    while(more){
        char op=cin.peek();//看第一个字符，不取走
        if(op==&apos;+&apos;||op==&apos;-&apos;){
            cin.get();//从输入中取走一个字符
            int value=term_value();//求出第二项的值
            if(op==&apos;+&apos;) result+=value;
            else result-=value; 
        } 
        else more=false;
    } 
    return result;
}
int term_value(){
    int result=factor_value();
    while(true){
        char op=cin.peek();
        if(op==&apos;*&apos;||op==&apos;/&apos;){
            cin.get();//去掉*号或者/除号
            int value=factor_value();
            if(op==&apos;*&apos;) 
                result*=value;
            else
                result/=value;
        }else{
            break;
        }
    }
    return result;
}
int factor_value(){//求一个因子的值 
    int result=0;
    char c=cin.peek();
    if(c==&apos;(&apos;){
        cin.get();
        result=expression_value();
        cin.get();
    }
    else{
        while(isdigit(c)){
            result=10*result+c-&apos;0&apos;;
            cin.get();
            c=cin.peek();
        }
    }
    return result;
}
</code></pre><h3 id="例题2-爬楼梯"><a href="#例题2-爬楼梯" class="headerlink" title="例题2 爬楼梯"></a>例题2 爬楼梯</h3><pre><code>#include &lt;iostream&gt;  
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt; 
using namespace std;  
int upstaris(int n){
    if(n==0)
        return 1;
    else if(n&lt;0)
        return 0;
    else 
        return upstaris(n-1)+upstaris(n-2);
}
int main()  
{  
    int n;
    while(cin&gt;&gt;n)
    {
        cout&lt;&lt;upstaris(n)&lt;&lt;endl; 
    }
    return 0;
}
</code></pre><h3 id="例题3-放苹果"><a href="#例题3-放苹果" class="headerlink" title="例题3 放苹果"></a>例题3 放苹果</h3><h3 id="例题4-算24"><a href="#例题4-算24" class="headerlink" title="例题4 算24"></a>例题4 算24</h3><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><h2 id="动态规划-一"><a href="#动态规划-一" class="headerlink" title="动态规划(一)"></a>动态规划(一)</h2><h3 id="例题1-数字三角形-1"><a href="#例题1-数字三角形-1" class="headerlink" title="例题1.数字三角形(1)"></a>例题1.数字三角形(1)</h3><p>数字三角形递归超时版本</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define MAX 101
using namespace std;

int D[MAX][MAX];
int n;
int MaxSum(int i,int j){
    if(i==n)
        return D[i][j];    
    int x=MaxSum(i+1,j);
    int y=MaxSum(i+1,j+1);
    return max(x,y)+D[i][j];
}
int main(){
    int i,j;
    cin&gt;&gt;n;
    for(i=1;i&lt;=n;i++)
        for（j=1;j&lt;=i;j++）
            cin&gt;&gt;D[i][j];
    cout&lt;&lt;MaxSum(1,1)&lt;&lt;endl;
    return 0;
}
</code></pre><p>数字三角形的记忆递归型动归程序：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define MAX 101
using namespace std;
int maxSum[MAX][MAX];
int D[MAX][MAX];
int n;
int MaxSum(int i,int j){
    if(maxSum[i][j]!=-1)
        return maxSum[i][j];
    if(i==n)
        maxSum[i][j]= D[i][j];
    else {
    int x=MaxSum(i+1,j);
    int y=MaxSum(i+1,j+1);
    maxSum[i][j]=max(x,y)+D[i][j];
    }    

    return maxSum[i][j];
}
int main(){
    int i,j;
    cin&gt;&gt;n;
    for(i=1;i&lt;=n;i++)
        for(j=1;j&lt;=i;j++){
            cin&gt;&gt;D[i][j];
            maxSum[i][j]=-1;
        }
    cout&lt;&lt;MaxSum(1,1)&lt;&lt;endl;
    return 0;
}
</code></pre><h3 id="例题1-数字三角形-2"><a href="#例题1-数字三角形-2" class="headerlink" title="例题1.数字三角形(2)"></a>例题1.数字三角形(2)</h3>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/02/15/慕课程序与算法设计-二/" class="archive-article-date">
  	<time datetime="2017-02-15T01:59:15.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-02-15</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-蓝桥杯在线题解算法训练" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/11/蓝桥杯在线题解算法训练/">蓝桥杯在线题解算法训练</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>感觉现在只能写水题。<br>水题爱好者。<br>表达式求值</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt; 
using namespace std;  
int factor_value();//读入一个因子
int term_value();//读入一项
int expression_value();//读入表达式 
int main()  
{  
    cout&lt;&lt;expression_value()&lt;&lt;endl;
    return 0;
}
int expression_value(){
    int result=term_value();//求一项的值
    bool more=true;//还有没有其他项
    while(more){
        char op=cin.peek();//看第一个字符，不取走
        if(op==&apos;+&apos;||op==&apos;-&apos;){
            cin.get();//从输入中取走一个字符
            int value=term_value();//求出第二项的值
            if(op==&apos;+&apos;) result+=value;
            else result-=value; 
        } 
        else more=false;
    } 
    return result;
}
int term_value(){
    int result=factor_value();
    while(true){
        char op=cin.peek();
        if(op==&apos;*&apos;||op==&apos;/&apos;){
            cin.get();//去掉*号或者/除号
            int value=factor_value();
            if(op==&apos;*&apos;) 
                result*=value;
            else
                result/=value;
        }else{
            break;
        }
    }
    return result;
}
int factor_value(){//求一个因子的值 
    int result=0;
    char c=cin.peek();
    if(c==&apos;(&apos;){
        cin.get();
        result=expression_value();
        cin.get();
    }
    else{
        while(isdigit(c)){
            result=10*result+c-&apos;0&apos;;
            cin.get();
            c=cin.peek();
        }
    }
    return result;
}
</code></pre><p>编写一函数lcm，求两个正整数的最小公倍数。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#define pi 3.1415926

using namespace std;

 int get_gcd(int x,int y)//最大公因数 
  {
      int r;
      if(x&lt;y)
      {
          r=x;
          x=y;
         y=r;
      }
     r=x%y;
     while(r)
     {
        x=y;
         y=r;
         r=x%y;
     }
         return y;
 }
 int get_lcm(int x,int y)//最小公倍数 
 {
  return (x*y)/(get_gcd(x,y));
 }
int main() {
    int m,n;
    scanf(&quot;%d %d&quot;,&amp;m,&amp;n);

    cout&lt;&lt;get_lcm(m,n)&lt;&lt;endl;
    return 0;
}
</code></pre><p>从键盘读入n个整数，使用动态数组存储所读入的整数，并计算它们的和与平均值分别输出。要求尽可能使用函数实现程序代码。平均值为小数的只保留其整数部分。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
using namespace std;
int main() {
    vector&lt;int&gt; ans;
    int n;
    int t;
    int sum=0;
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++){
        cin&gt;&gt;t;
        ans.push_back(t);
        sum+=t;
    }
    cout&lt;&lt;sum&lt;&lt;&quot; &quot;&lt;&lt;sum/n&lt;&lt;endl;
    return 0;
}
</code></pre><p>使用宏实现计算球体体积的功能。用户输入半径，系统输出体积。不能使用函数，pi=3.1415926,结果精确到小数点后五位。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#define pi 3.1415926
using namespace std;
int main() {
    double a;
    cin&gt;&gt;a;
    printf(&quot;%.5f&quot;,a*4/3.0*pi*a*a);
    return 0;
}
</code></pre><p>已知一个正整数N，问从1~N中任选出三个数，他们的最小公倍数最大可以为多少。</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#include &lt;queue&gt;  
#include &lt;vector&gt;  
#include &lt;stdio.h&gt;  
using namespace std;  
int main()  
{  
    long long int n,ans;  
    cin&gt;&gt;n;  
    if(n&lt;3)  
        ans=n;  
    else{  
    if(n%2!=0)  
        ans=n*(n-1)*(n-2);  
    else if(n%3!=0)  
        ans=n*(n-1)*(n-3);  
    else  
        ans=(n-1)*(n-2)*(n-3);  
    }  
     cout&lt;&lt;ans&lt;&lt;endl;  
    return  0;  
}  
</code></pre><p>编写一个程序，首先输入一个整数，例如5，然后在屏幕上显示如下的图形（5表示行数）：<br>　　<em> </em> <em> </em> <em>
　　</em> <em> </em> <em>
　　</em> <em> </em><br>　　<em> </em><br>　　*</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
int main() {
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=n;i&gt;=1;i--){
        for(int j=i;j&gt;=1;j--){
            printf(&quot;* &quot;);
        }
        printf(&quot;\n&quot;);
    } 
    return 0;
}
</code></pre><p>编写一个程序，输入一个字符串（长度不超过20），然后把这个字符串内的每一个字符进行大小写变换，即将大写字母变成小写，小写字母变成大写，然后把这个新的字符串输出。<br>　　输入格式：输入一个字符串，而且这个字符串当中只包含英文字母，不包含其他类型的字符，也没有空格。<br>　　输出格式：输出经过转换后的字符串。</p>
<pre><code>#include &lt;iostream&gt;  

using namespace std;  

int main()  
{  
    char a[20];  
    int i = 0;  
    cin&gt;&gt;a;  
    for(;a[i];i++)  
    {  
        if(a[i] &gt;= &apos;a&apos;&amp;&amp;a[i] &lt;= &apos;z&apos;)  
            a[i] -= 32;  
        else if(a[i] &gt;= &apos;A&apos;&amp;&amp;a[i] &lt;= &apos;Z&apos;)  
            a[i] += 32;  
    }  
    for(i = 0;a[i];i++)  
        cout&lt;&lt;a[i];  
    return 0;
}
</code></pre><p>Anagrams指的是具有如下特性的两个单词：在这两个单词当中，每一个英文字母（不区分大小写）所出现的次数都是相同的。例如，“Unclear”和“Nuclear”、“Rimon”和“MinOR”都是Anagrams。编写一个程序，输入两个单词，然后判断一下，这两个单词是否是Anagrams。每一个单词的长度不会超过80个字符，而且是大小写无关的。<br>　　输入格式：输入有两行，分别为两个单词。<br>　　输出格式：输出只有一个字母Y或N，分别表示Yes和No。<br>　　输入输出样例</p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt; 
#include &lt;algorithm&gt;
using namespace std;
bool cmp(int a,int b){return a&gt;b;
}
int main()
{
    string a,b;
    map&lt;char,int&gt; zm;//字母映射
    cin&gt;&gt;a&gt;&gt;b;
    for(int i=0;i&lt;a.size();i++){
        zm[a[i]]++;
    }
    if(a.size()!=b.size()){
        cout&lt;&lt;&quot;N&quot;&lt;&lt;endl;
    }else{
        map&lt;char,int&gt;::iterator   it;
        for(it=zm.begin();it!=zm.end();it++){
            char ac=it-&gt;first;
            char bc;
            if(ac&gt;=&apos;a&apos;&amp;&amp;ac&lt;= &apos;z&apos;) 
             bc=ac-32;
            else
                 bc=ac+32; 
            int aci=0;
            for(int j=0;j&lt;b.size();j++){
                if(b[j]==ac||b[j]==bc){
                    aci++;
                }
            }
            if(aci==it-&gt;second)
                continue;
            else
            {
                cout&lt;&lt;&quot;N&quot;&lt;&lt;endl;
                break;
            }
        }
        if(it==zm.end()){
            cout&lt;&lt;&quot;Y&quot;&lt;&lt;endl;
        }

    }

    return 0;
}
</code></pre><p>编写一个程序，输入3个整数，然后程序将对这三个整数按照从大到小进行排列。<br>　　输入格式：输入只有一行，即三个整数，中间用空格隔开。<br>　　输出格式：输出只有一行，即排序后的结果。<br>　　输入输出样例</p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;
bool cmp(int a,int b){return a&gt;b;
}
int main()
{
    int a[3];
    scanf(&quot;%d %d %d&quot;,&amp;a[0],&amp;a[1],&amp;a[2]);
    sort(a,a+3,cmp);
    cout&lt;&lt;a[0]&lt;&lt;&quot; &quot;&lt;&lt;a[1]&lt;&lt;&quot; &quot;&lt;&lt;a[2];           
    return 0;
}
</code></pre><p> 6-1 递归求二项式系数值  </p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;
int getck(int k,int n){
    if(k==0||n==k){
            return 1;
    }else{
        return getck(k,n-1)+getck(k-1,n-1);
    }
}
int main()
{
    int k,n;
    cin&gt;&gt;k&gt;&gt;n;
    cout&lt;&lt;getck(k,n);           
    return 0;
}
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/02/11/蓝桥杯在线题解算法训练/" class="archive-article-date">
  	<time datetime="2017-02-11T01:59:34.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-02-11</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-蓝桥杯在线测试题基础题解-二" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/09/蓝桥杯在线测试题基础题解-二/">蓝桥杯在线测试题基础题解(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>定义一个学生结构体类型student，包括4个字段，姓名、性别、年龄和成绩。然后在主函数中定义一个结构体数组（长度不超过1000），并输入每个元素的值，程序使用冒泡排序法将学生按照成绩从小到大的顺序排序，然后输出排序的结果。<br>输入格式：第一行是一个整数N（N&lt;1000），表示元素个数；接下来N行每行描述一个元素，姓名、性别都是长度不超过20的字符串，年龄和成绩都是整型。<br>输出格式：按成绩从小到大输出所有元素，若多个学生成绩相同则成绩相同的同学之间保留原来的输入顺序。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

struct student {
    string name;
    string sex;
    int age;
    int grade;
};

void BubbleSort(student arr[], int n)
{
    for (int i = 0; i &lt; n - 1; i++) {
        for (int j = 0; j &lt; n - i - 1; j++) {
            if (arr[j].grade &gt; arr[j + 1].grade) {
                student temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
int main (){
    int n;
    cin&gt;&gt;n;
    student stu[1000];
    for(int i=0;i&lt;n;i++){
        cin&gt;&gt;stu[i].name&gt;&gt;stu[i].sex&gt;&gt;stu[i].age&gt;&gt;stu[i].grade;
    }
    BubbleSort(stu,n);
    for(int j=0;j&lt;n;j++){
        cout&lt;&lt;stu[j].name&lt;&lt;&quot; &quot;&lt;&lt;stu[j].sex&lt;&lt;&quot; &quot;&lt;&lt;stu[j].age&lt;&lt;&quot; &quot;&lt;&lt;stu[j].grade&lt;&lt;endl;
    }
    return 0;
} 
</code></pre><p>s01串</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main (){
    string s=&quot;0&quot;;
    int n;
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++){
        string t; 
        for(int j=0;j&lt;s.size();j++){
            if(s[j]==&apos;1&apos;){
                t+=&quot;01&quot;;
            }
            if(s[j]==&apos;0&apos;){
                t+=&quot;1&quot;;
            }
        } 
        s=t;
    }
    cout&lt;&lt;s&lt;&lt;endl;
    return 0;
} 
</code></pre><p>题目1 最大值最小值</p>
<pre><code>#include &lt;iostream&gt;

using namespace std;

int main (){
    int n;
    cin&gt;&gt;n;
    int Max=-1000000;
    int t[1000000];
    int Min=1000000;
    for(int i=0;i&lt;n;i++){
        cin&gt;&gt;t[i];
        if(t[i]&gt;Max)
            Max=t[i];
        if(t[i]&lt;Min)
            Min=t[i];
    }
    cout&lt;&lt;Max&lt;&lt;&quot; &quot;&lt;&lt;Min&lt;&lt;endl;
    return 0;
} 
</code></pre><p>普通版本九宫格：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
using namespace std;
int EA[3][3];
int main (){
    for(int i=0;i&lt;3;i++){
        for(int j=0;j&lt;3;j++){
            cin&gt;&gt;EA[i][j]; 
        }
    }
    int sum=0;
    sum=EA[0][0]+EA[0][1]+EA[0][2];
    if(sum==EA[0][0]+EA[1][0]+EA[2][0]&amp;&amp;
        sum==EA[0][0]+EA[1][1]+EA[2][2]&amp;&amp;
        sum==EA[2][0]+EA[2][1]+EA[2][2]&amp;&amp;
        sum==EA[0][2]+EA[1][2]+EA[2][2])
        cout&lt;&lt;&quot;1&quot;;
    else
        cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; 
    return 0;
} 
</code></pre><p>算法提高 11-1实现strcmp函数</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
using namespace std;
int myStrcmp(char *s1,char *s2){
    int ptr1=0;
    int ptr2=0;//两个指针 
    while(s1[ptr1]!=&apos;\0&apos;&amp;&amp;s2[ptr2]!=&apos;\0&apos;){
        //两个字符串比较
        if(s1[ptr1]!=s2[ptr2])
            return s1[ptr1]&gt;s2[ptr2];
        ptr1++;
        ptr2++; 
    }
    if(s1[ptr1]!=&apos;\0&apos;)
        ptr1++;
    if(s2[ptr2]!=&apos;\0&apos;)
        ptr2++;
    if(ptr1&gt;ptr2){
        return 1;
    }else if(ptr1==ptr2){
        return 0;
    }else if(ptr1&lt;ptr2){
        return -1;
    }
}
int main (){
    char a[100],b[100];
    cin&gt;&gt;a;
    cin&gt;&gt;b;
    cout&lt;&lt;myStrcmp(a,b)&lt;&lt;endl;
    return 0;
} 
</code></pre><p>删除重复元素：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
using namespace std;

int main (){
    string s;
    cin&gt;&gt;s;
    map&lt;char,int&gt; ch;
    bool v[101];
    memset(v,true,s.size());
    for(int i=0;i&lt;s.size();i++){
        ch[s[i]]++;//存储出现字符的次数 
    }
    map&lt;char,int&gt;::iterator it;
    for(it=ch.begin();it!=ch.end();it++){
        if(it-&gt;second&gt;1){
            for(int t=0;t&lt;s.size();t++){
                if(s[t]==it-&gt;first){
                    v[t]=false;
                }
            }
        }
    }
    for(int p=0;p&lt;s.size();p++)
        if(v[p])
            cout&lt;&lt;s[p];
    return 0;
} 
</code></pre><p>12-1三角形</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

typedef struct{
    double x,y;
}Point;

void Perimeter(Point *p){
    printf(&quot;%.2lf\n&quot;,sqrt((p[1].x - p[0].x)*(p[1].x - p[0].x)+(p[1].y - p[0].y)*(p[1].y - p[0].y))+
        sqrt((p[2].x - p[0].x)*(p[2].x - p[0].x)+(p[2].y - p[0].y)*(p[2].y - p[0].y)) +
        sqrt((p[2].x - p[1].x)*(p[2].x - p[1].x)+(p[2].y - p[1].y)*(p[2].y - p[1].y)));
}

void Area(Point *p){
    //海伦公式sqrt(p(p-a)(p-b)(p-c))or向量法
    //这里采用向量法 
    Point p1[2];
    double cos_theta,sin_theta,model1,model2;
    p1[0].x = p[1].x - p[0].x,p1[0].y = p[1].y - p[0].y;
    p1[1].x = p[2].x - p[0].x,p1[1].y = p[2].y - p[0].y;
    model1 = sqrt((p[1].x - p[0].x)*(p[1].x - p[0].x)+(p[1].y - p[0].y)*(p[1].y - p[0].y));
    model2 = sqrt((p[2].x - p[0].x)*(p[2].x - p[0].x)+(p[2].y - p[0].y)*(p[2].y - p[0].y));
    cos_theta = (p1[0].x * p1[1].x  + p1[0].y * p1[1].y)/(model1*model2);
    sin_theta = sqrt(1-cos_theta*cos_theta);
    printf(&quot;%.2lf\n&quot;,0.5*model1*model2*sin_theta); 
}

void Circumcenter(Point *p){
    //外接圆,圆心到三个顶点的距离相等列方程,可解出(x,y) 
    double denominator,delta_x,delta_y;
    denominator = 2*(p[1].x - p[0].x)*(p[2].y - p[0].y) - 2*(p[1].y - p[0].y)*(p[2].x - p[0].x);
    delta_x = (p[2].y - p[0].y)*(p[1].x*p[1].x + p[1].y*p[1].y - p[0].x*p[0].x - p[0].y*p[0].y)
            -(p[1].y - p[0].y)*(p[2].x*p[2].x + p[2].y*p[2].y - p[0].x*p[0].x - p[0].y*p[0].y);
    delta_y = (p[1].x - p[0].x)*(p[2].x*p[2].x + p[2].y*p[2].y - p[0].x*p[0].x - p[0].y*p[0].y)
            -(p[2].x - p[0].x)*(p[1].x*p[1].x + p[1].y*p[1].y - p[0].x*p[0].x - p[0].y*p[0].y);
    printf(&quot;%.2lf %.2lf\n&quot;,delta_x/denominator,delta_y/denominator);
}

void Center_Of_Gravity(Point *p) {
    //一个顶点到另一边的中心连线的2/3处 
    Point p1;
    p1.x = (p[0].x + p[1].x)/2.0,p1.y = (p[0].y + p[1].y)/2.0;
    printf(&quot;%.2lf %.2lf\n&quot;,p[2].x+2.0*(p1.x - p[2].x)/3,p[2].y+2.0*(p1.y - p[2].y)/3);//注意哪个减去哪个
}

int main(){
    Point p[3];
    int i;
    for(i = 0; i &lt; 3; i ++)
        scanf(&quot;%lf%lf&quot;,&amp;p[i].x,&amp;p[i].y);
    Perimeter(p);
    Area(p);
    Circumcenter(p);
    Center_Of_Gravity(p);
    return 0;
}
</code></pre><p>扑克排序：</p>
<pre><code>#include &lt;iostream&gt;  
#include &lt;cstring&gt;
#include &lt;algorithm&gt; 
using namespace std;  
struct poker{
    char number;
    char color;
};
bool cmp(poker p0,poker p1){
    int n0,c0;//第一个p0的number和color 
    int n1,c1;
    if(p0.number&gt;=&apos;2&apos;&amp;&amp;p0.number&lt;=&apos;9&apos;){
        n0=p0.number-&apos;0&apos;;
    }else if(p0.number==&apos;1&apos;){
        n0=10;
    }else if(p0.number==&apos;J&apos;){
        n0=11;
    }else if(p0.number==&apos;Q&apos;){
        n0=12;
    }else if(p0.number==&apos;K&apos;){
        n0=13;
    }else if(p0.number==&apos;A&apos;){
        n0=14;
    }
    //n1赋值 
    if(p1.number&gt;=&apos;2&apos;&amp;&amp;p1.number&lt;=&apos;9&apos;){
        n1=p1.number-&apos;0&apos;;
    }else if(p1.number==&apos;1&apos;){
        n1=10;
    }else if(p1.number==&apos;J&apos;){
        n1=11;
    }else if(p1.number==&apos;Q&apos;){
        n1=12;
    }else if(p1.number==&apos;K&apos;){
        n1=13;
    }else if(p1.number==&apos;A&apos;){
        n1=14;
    }
    //c0
    if(p0.color==&apos;d&apos;)
        c0=1; 
    else if(p0.color==&apos;c&apos;){
        c0=2;
    }else if(p0.color==&apos;h&apos;){
        c0=3;
    }else if(p0.color==&apos;s&apos;){
        c0=4;
    }
    //c1
        if(p1.color==&apos;d&apos;)
        c1=1; 
    else if(p1.color==&apos;c&apos;){
        c1=2;
    }else if(p1.color==&apos;h&apos;){
        c1=3;
    }else if(p1.color==&apos;s&apos;){
        c1=4;
    }
    if(n0!=n1)
        return n0&lt;n1;
    else 
        return c0&lt;c1;
}
int main()  
{  
    char a[25];
    cin&gt;&gt;a;
    poker p[5];
    int ptr=0;//用来指向poker数组的指针 
    for(int i=0;i&lt;20;i++){
        if(a[i]!=&apos;1&apos;)
            p[ptr].number=a[i];
        else {
            p[ptr].number=&apos;1&apos;;
            i++;//跳过后面的0 
        }
        i++;
        p[ptr].color=a[i];
        ptr++;
    } 
    sort(p,p+5,cmp);//排序 
    for(int j=0;j&lt;5;j++){
        if(p[j].number==&apos;1&apos;)
            cout&lt;&lt;&quot;10&quot;;
        else
            cout&lt;&lt;p[j].number;
        cout&lt;&lt;p[j].color&lt;&lt;&quot; &quot;;
    }
    return 0;
}
</code></pre><p>Huffman树在编码中有着广泛的应用。在这里，我们只关心Huffman树的构造过程。<br>　　给出一列数{pi}={p0, p1, …, pn-1}，用这列数构造Huffman树的过程如下：<br>　　1. 找到{pi}中最小的两个数，设为pa和pb，将pa和pb从{pi}中删除掉，然后将它们的和加入到{pi}中。这个过程的费用记为pa + pb。<br>　　2. 重复步骤1，直到{pi}中只剩下一个数。<br>　　在上面的操作过程中，把所有的费用相加，就得到了构造Huffman树的总费用。<br>　　本题任务：对于给定的一个数列，现在请你求出用该数列构造Huffman树的总费用。</p>
<p>　　例如，对于数列{pi}={5, 3, 8, 2, 9}，Huffman树的构造过程如下：</p>
<p>　　1. 找到{5, 3, 8, 2, 9}中最小的两个数，分别是2和3，从{pi}中删除它们并将和5加入，得到{5, 8, 9, 5}，费用为5。<br>　　<br>　　2. 找到{5, 8, 9, 5}中最小的两个数，分别是5和5，从{pi}中删除它们并将和10加入，得到{8, 9, 10}，费用为10。<br>　　<br>　　3. 找到{8, 9, 10}中最小的两个数，分别是8和9，从{pi}中删除它们并将和17加入，得到{10, 17}，费用为17。</p>
<p>　　4. 找到{10, 17}中最小的两个数，分别是10和17，从{pi}中删除它们并将和27加入，得到{27}，费用为27。<br>　　<br>　　5. 现在，数列中只剩下一个数27，构造过程结束，总费用为5+10+17+27=59。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
//缺省是升序排序。sort中一个改变排序顺序的例子如下（降序）
//sort(huf.begin(), huf.end(), cmp);
bool cmp (const int a, const int b)
{
    return a &gt; b;
}
int main()
{
    int n;
    while (~scanf(&quot;%d&quot;, &amp;n)) {
        vector&lt;int&gt; huf;
        while (n--) {
            int t;
            scanf(&quot;%d&quot;, &amp;t);
            huf.push_back(t);
        }
        vector&lt;int&gt;::size_type size = huf.size();
        int cost = 0;
        while (size &gt;= 2) {
            sort(huf.begin(), huf.end(), cmp);
            int t = huf[size - 1] + huf[size - 2];
            cost += t;
            huf.pop_back();
            huf.pop_back();
            huf.push_back(t);
            size = huf.size();
        }
        printf(&quot;%d\n&quot;, cost);
    }
    return 0;
}
</code></pre><p>输入两个整数a和b，输出这两个整数的和。a和b都不超过100位。</p>
<pre><code>#include&lt;iostream&gt;  
#include&lt;cstdio&gt;  
#include&lt;cstring&gt;  
using namespace std;  
int main()  
{  
    char a1[100],b1[100];  
    int a[100],b[100],c[100];  
    int a1_len,b1_len,lenc,i,x;  
    memset(a,0,sizeof(a));   
    memset(b,0,sizeof(b));   
    memset(c,0,sizeof(c));  

    gets(a1);   
    gets(b1); //输入加数与被加数   

    a1_len=strlen(a1);   
    b1_len=strlen(b1);   

    for (i=0;i&lt;=a1_len-1;i++)   
    {  
        a[a1_len-i]=a1[i]-48; //将操作数放入a数组 　  
    }  

    for (i=0;i&lt;=b1_len-1;i++)  
    {  
        b[b1_len-i]=b1[i]-48; //将操作数放入b数组   
    }   

    lenc =1;   
    x=0;   

   while(lenc &lt;=a1_len || lenc &lt;=b1_len)   
   {   
        c[lenc]=a[lenc]+b[lenc]+x; //两数相加 　  
        x=c[lenc]/10;   //要进的位  
        c[lenc]=c[lenc]%10;     //进位后的数  
        lenc++;     //数组下标加1  
    }  

    c[lenc]=x;  
    if (c[lenc]==0)  
    {  
        lenc--; //处理最高进位   
    }   

    for (i=lenc;i&gt;=1;i--)  
    {  
        cout&lt;&lt;c[i]; //输出结果      
    }  
    cout&lt;&lt;endl;  

    return 0;  
}  
</code></pre><p>输入一个正整数n，输出n!的值。<br>　　其中n!=1<em>2</em>3<em>…</em>n。</p>
<pre><code>#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;string.h&gt;  
#define MAX 4000  
int main() {  
    int n,a[MAX],i,j,s,r=0;  
    scanf(&quot;%d&quot;,&amp;n);  
    memset(a,0,sizeof(a));  
    a[0]=1;  
    for(i=2;i&lt;=n;i++){  
        for(j=0;j&lt;MAX;j++){  
            s=a[j]*i+r;  
            r=s/10;//进位  
            a[j]=s%10;  
        }  
    }  
    for(i=MAX-1;i&gt;=0;i--){  
        if(a[i])  
            break;  
    }  
    for(j=i;j&gt;=0;j--)//倒序输出  
        printf(&quot;%d&quot;,a[j]);  
    return 0;  
}  
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/02/09/蓝桥杯在线测试题基础题解-二/" class="archive-article-date">
  	<time datetime="2017-02-09T02:59:28.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-02-09</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-蓝桥杯在线测试题基础题解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/31/蓝桥杯在线测试题基础题解/">蓝桥杯在线测试题基础题解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>tips:1. 添加代码可以用tab缩进，也可以用&lt; code&gt;\&lt; /code&gt;来放置代码。<br>给定一个年份，判断这一年是不是闰年。</p>
<p>当以下情况之一满足时，这一年是闰年：</p>
<ol>
<li><p>年份是4的倍数而不是100的倍数；</p>
</li>
<li><p>年份是400的倍数。</p>
</li>
</ol>
<p>其他的年份都不是闰年。</p>
<pre><code>#include&lt;stdio.h&gt;  
int main()  
{  
    int year;
    scanf(&quot;%d&quot;,&amp;year);
    if(year%4==0&amp;&amp;year%100!=0){
        printf(&quot;yes\n&quot;);
    }else if(year%400==0){
        printf(&quot;yes\n&quot;);
    }else{
        printf(&quot;no\n&quot;);
    }
    return 0;  
}  
</code></pre><p>对于长度为5位的一个01串，每一位都可能是0或1，一共有32种可能。它们的前几个是：</p>
<p>00000</p>
<p>00001</p>
<p>00010</p>
<p>00011</p>
<p>00100</p>
<p>请按从小到大的顺序输出这32种01串。</p>
<pre><code>#include&lt;cstdio&gt;  
int main()  
{  
    for(int a=0;a&lt;2;a++)  
        for(int b=0;b&lt;2;b++)  
            for(int c=0;c&lt;2;c++)  
                for(int d=0;d&lt;2;d++)  
                    for(int e=0;e&lt;2;e++)  
                        printf(&quot;%d%d%d%d%d\n&quot;,a,b,c,d,e);  
    return 0;  
}  
</code></pre><p>利用字母可以组成一些美丽的图形，下面给出了一个例子：<br>ABCDEFG<br>BABCDEF<br>CBABCDE<br>DCBABCD<br>EDCBABC<br>这是一个5行7列的图形，请找出这个图形的规律，并输出一个n行m列的图形。</p>
<pre><code>#include&lt;cstdio&gt;  
char ans[30][30];  
int main()  
{  
    for(int i=1;i&lt;=26;i++)  
        ans[i][1]=ans[1][i]=i+&apos;A&apos;-1;  
    for(int i=1;i&lt;=26;i++)  
    {  
        for(int j=1;j&lt;=26;j++)         
            ans[i+1][j+1]=ans[i][j];          
    }  
    int n,m;  
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);  
    for(int i=1;i&lt;=n;i++)  
    {  
        for(int j=1;j&lt;=m;j++)  
        {  
            printf(&quot;%c&quot;,ans[i][j]);  
        }  
        printf(&quot;\n&quot;);  
    }  
    return 0;  
}  
</code></pre><p>给出n个数，找出这n个数的最大值，最小值，和。</p>
<pre><code>#include&lt;stdio.h&gt;
int a[10001];
int main()  
{  
    int n;
    int i;
    int Max=-10001,Min=10001,Sum=0;
    scanf(&quot;%d&quot;,&amp;n);
    for(i=1;i&lt;=n;i++){
        scanf(&quot;%d&quot;,&amp;a[i]);
        if(Max&lt;a[i]){
            Max=a[i];
        }
        if(Min&gt;a[i]){
            Min=a[i];
        }
        Sum+=a[i];
    }
    printf(&quot;%d\n&quot;,Max);
    printf(&quot;%d\n&quot;,Min);
    printf(&quot;%d\n&quot;,Sum);
    return 0;  
}
</code></pre><p>给出一个包含n个整数的数列，问整数a在数列中的第一次出现是第几个。</p>
<pre><code>#include&lt;stdio.h&gt;
int a[1001];
int main()  
{  
    int n;
    int i;
    scanf(&quot;%d&quot;,&amp;n);
    for(i=1;i&lt;=n;i++){
        scanf(&quot;%d&quot;,&amp;a[i]);
    }
    int n1;
    scanf(&quot;%d&quot;,&amp;n1);
    for(i=1;i&lt;=n;i++){
        if(a[i]==n1)
            break;
    }
    if(i&lt;=n){
        printf(&quot;%d\n&quot;,i);
    }else{
        printf(&quot;%d\n&quot;,-1);
    }
    return 0;  
}
</code></pre><p>杨辉三角形又称Pascal三角形，它的第i+1行是(a+b)i的展开式的系数。</p>
<p>　　<br>它的一个重要性质是：三角形中的每个数字等于它两肩上的数字相加。</p>
<p>　　<br>下面给出了杨辉三角形的前4行：</p>
<p>　　<br>   1</p>
<p>　　<br>  1 1</p>
<p>　　<br> 1 2 1</p>
<p>　　<br>1 3 3 1</p>
<p>　　<br>给出n，输出它的前n行。</p>
<pre><code>#include&lt;cstdio&gt;  
int ans[36][36]={0};  
int main()  
{  
    ans[1][1]=1;  
    for(int i=2;i&lt;=34;i++)  
    {  
        for(int j=1;j&lt;=i;j++)  
        {  
            ans[i][j]=ans[i-1][j]+ans[i-1][j-1];  
        }  
    }  
    int n;  
    scanf(&quot;%d&quot;,&amp;n);  
    for(int i=1;i&lt;=n;i++)  
    {  
        printf(&quot;%d&quot;,ans[i][1]);  
        for(int j=2;j&lt;=i;j++)  
        {  
            printf(&quot; %d&quot;,ans[i][j]);  
        }  
        printf(&quot;\n&quot;);  
    }  
    return 0;  
}
</code></pre><p>特殊的数字：<br>153是一个非常特殊的数，它等于它的每位数字的立方和，即153=1<em>1</em>1+5<em>5</em>5+3<em>3</em>3。编程求所有满足这种条件的三位十进制数。</p>
<pre><code>#include &lt;stdio.h&gt;

int main (){
    int i=100;
    int s0,s1,s2;
    while(i&lt;=999){
        int t=i;
        s0=t%10;
        t=t/10;
        s1=t%10;
        t=t/10;
        s2=t%10;
        if((s0*s0*s0+s1*s1*s1+s2*s2*s2)==i)
            printf(&quot;%d\n&quot;,i);
        i++;    
    }
    return 0;
} 
</code></pre><p>回文数:</p>
<p>1221是一个非常特殊的数，它从左边读和从右边读是一样的，编程求所有这样的四位十进制数。</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

int main() {
    int i=1000;
    int t;
    int s[6];
    for(; i&lt;=9999; i++) {
        t=i;
        s[0]=t%10;
        t=t/10;
        s[1]=t%10;
        t=t/10;
        s[2]=t%10;
        t=t/10;
        s[3]=t%10;
            if(s[0]==s[3]&amp;&amp;s[1]==s[2])
                printf(&quot;%d\n&quot;,i);
        }

    return 0;
}
</code></pre><p>特殊回文数：</p>
<p>123321是一个非常特殊的数，它从左边读和从右边读是一样的。<br>　　输入一个正整数n， 编程求所有这样的五位和六位十进制数，满足各位数字之和等于n 。</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
int main() {
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    int i=10000;
    int t;
    int s[6];
    for(; i&lt;999999; i++) {
        t=i;
        int j=0;
        //5位数
        if(i&lt;100000) {
            s[0]=t%10;
            t=t/10;
            s[1]=t%10;
            t=t/10;
            s[2]=t%10;
            t=t/10;
            s[3]=t%10;
            t=t/10;
            s[4]=t%10;
            if((s[0]+s[1]+s[2]+s[3]+s[4])==n) {
                if(s[0]==s[4]&amp;&amp;s[1]==s[3])
                    printf(&quot;%d\n&quot;,i);
            }
        } else {
            s[0]=t%10;
            t=t/10;
            s[1]=t%10;
            t=t/10;
            s[2]=t%10;
            t=t/10;
            s[3]=t%10;
            t=t/10;
            s[4]=t%10;
            t=t/10;
            s[5]=t%10;
            if((s[0]+s[1]+s[2]+s[3]+s[4]+s[5])==n)
                if(s[0]==s[5]&amp;&amp;s[1]==s[4]&amp;&amp;s[2]==s[3])
                    printf(&quot;%d\n&quot;,i);
        }
    }
    return 0;
}
</code></pre><p>Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。</p>
<p>当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。<br>思路是，没有必要把每个数都求出来，只需要求每个数除100007的余数</p>
<pre><code>#include&lt;cstdio&gt;  
const int mod=10007;  
const int MAXN=1000000+10;  
int ans[MAXN];  
int main()  
{  
    ans[1]=ans[2]=1;  
    int n;  
     scanf(&quot;%d&quot;,&amp;n);  
  for(int i=3;i&lt;=n;i++)  
    ans[i]=(ans[i-1]+ans[i-2])%mod;  
    printf(&quot;%d\n&quot;,ans[n]);  
    return 0;  
}  
</code></pre><p>16进制转8进制：<br><code>    </code></p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
const int MAXN=100000; 
char s[MAXN];
char two[MAXN*4];//二进制 
int eight[MAXN*4];//八进制 
int main()
int t;
scanf(&quot;%d&quot;,&amp;t);
while(t--){
    scanf(&quot;%s&quot;,s);
    int n=strlen(s),len=0;
    for(int i=0;i&lt;n;i++){
        switch(s[i])  
        {  
        case &apos;0&apos;:sprintf(two+len,&quot;%s&quot;,&quot;0000&quot;);break;  
        case &apos;1&apos;:sprintf(two+len,&quot;%s&quot;,&quot;0001&quot;);break;  
        case &apos;2&apos;:sprintf(two+len,&quot;%s&quot;,&quot;0010&quot;);break;  
        case &apos;3&apos;:sprintf(two+len,&quot;%s&quot;,&quot;0011&quot;);break;  
        case &apos;4&apos;:sprintf(two+len,&quot;%s&quot;,&quot;0100&quot;);break;  
        case &apos;5&apos;:sprintf(two+len,&quot;%s&quot;,&quot;0101&quot;);break;  
        case &apos;6&apos;:sprintf(two+len,&quot;%s&quot;,&quot;0110&quot;);break;  
        case &apos;7&apos;:sprintf(two+len,&quot;%s&quot;,&quot;0111&quot;);break;  
        case &apos;8&apos;:sprintf(two+len,&quot;%s&quot;,&quot;1000&quot;);break;  
        case &apos;9&apos;:sprintf(two+len,&quot;%s&quot;,&quot;1001&quot;);break;  
        case &apos;A&apos;:sprintf(two+len,&quot;%s&quot;,&quot;1010&quot;);break;  
        case &apos;B&apos;:sprintf(two+len,&quot;%s&quot;,&quot;1011&quot;);break;  
        case &apos;C&apos;:sprintf(two+len,&quot;%s&quot;,&quot;1100&quot;);break;  
        case &apos;D&apos;:sprintf(two+len,&quot;%s&quot;,&quot;1101&quot;);break;  
        case &apos;E&apos;:sprintf(two+len,&quot;%s&quot;,&quot;1110&quot;);break;  
        case &apos;F&apos;:sprintf(two+len,&quot;%s&quot;,&quot;1111&quot;);break;  
        }  
        len+=4;  
    } 
    int i=len-1,len2=0;
    for(i=len-1;i&gt;=2;i-=3){
        eight[len2++]= two[i]-&apos;0&apos;+(two[i-1]-&apos;0&apos;)*2+(two[i-2]-&apos;0&apos;)*4;//转化成八进制 
    }
    if(i==2)  
        eight[len2++]= two[i]-&apos;0&apos;+(two[i-1]-&apos;0&apos;)*2+(two[i-2]-&apos;0&apos;)*4;  
    else if(i==1)  
        eight[len2++]= two[i]-&apos;0&apos;+(two[i-1]-&apos;0&apos;)*2;  
    else if(i==0)  
        eight[len2++]= two[i]-&apos;0&apos;;  

    i=len2-1;  
    while(eight[i]==0)  
        i--;  
    for(;i&gt;=0;i--)  
        printf(&quot;%d&quot;,eight[i]);  
    printf(&quot;\n&quot;);  
} 
return 0;
}
</code></pre><p></p>
<p>16进制转10进制：<br><code></code></p>
<pre><code>    #include &lt;cstdio&gt;
    #include &lt;iostream&gt;
    #include &lt;cstring&gt;
    #include &lt;cmath&gt;
    const int MAXN=100000;
    long long Decimal=0;
    using namespace std;
    int main() {
        char s[8]; 
        scanf(&quot;%s&quot;,s);
        int n=strlen(s),len=0;
        for(int i=0; i&lt;n; i++) {
            switch(s[i]) {
        case &apos;0&apos;:
                break;
        case &apos;1&apos;:
            Decimal=Decimal+pow(16,n-i-1);
            break;
        case &apos;2&apos;:
            Decimal=Decimal+2*pow(16,n-i-1);
            break;
        case &apos;3&apos;:
            Decimal=Decimal+3*pow(16,n-i-1);
            break;
        case &apos;4&apos;:
            Decimal=Decimal+4*pow(16,n-i-1);
            break;
        case &apos;5&apos;:
            Decimal=Decimal+5*pow(16,n-i-1);
            break;
        case &apos;6&apos;:
            Decimal=Decimal+6*pow(16,n-i-1);
            break;
        case &apos;7&apos;:
            Decimal=Decimal+7*pow(16,n-i-1);
            break;
        case &apos;8&apos;:
            Decimal=Decimal+8*pow(16,n-i-1);
            break;
        case &apos;9&apos;:
            Decimal=Decimal+9*pow(10,n-i-1);
            break;
        case &apos;A&apos;:
            Decimal=Decimal+10*pow(16,n-i-1);
            break;
        case &apos;B&apos;:
            Decimal=Decimal+11*pow(16,n-i-1);
            break;
        case &apos;C&apos;:
            Decimal=Decimal+12*pow(16,n-i-1);
            break;
        case &apos;D&apos;:
            Decimal=Decimal+13*pow(16,n-i-1);
            break;
        case &apos;E&apos;:
            Decimal=Decimal+14*pow(16,n-i-1);
            break;
        case &apos;F&apos;:
            Decimal=Decimal+15*pow(16,n-i-1);
            break;
        }
    }
    cout&lt;&lt;Decimal&lt;&lt;endl;
    return 0;
}
</code></pre><p></p>
<p>10进制转16进制:<br><code></code></p>
<pre><code>#include&lt;cstdio&gt;
int ans[30]= {0};
int main() {
    int a;
    scanf(&quot;%d&quot;,&amp;a);
    int len=0;
    while(a) {
        ans[len++]=a % 16;
        a/=16;
    }
    while(ans[len]==0 &amp;&amp; len&gt;=0)
        len--;
    if(len&gt;=0)
        for(int i=len; i&gt;=0; i--) {
            if(ans[i] &gt; 9)
                printf(&quot;%c&quot;,ans[i]-10+&apos;A&apos;);
            else
                printf(&quot;%d&quot;,ans[i]);
        }
    else
        printf(&quot;0&quot;);
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre><p><br>另外再附一个也通过的,简单点，就是%d  %o   %x      %X<br>分别是 十进制，八进制，十六进制（小写），十六进制（大些）的输出格式！:<br><code></code></p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
using namespace std;
int main() {
    long long t;
    cin&gt;&gt;t;
    printf(&quot;%X&quot;,t);
    return 0;
}
</code></pre><p></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/01/31/蓝桥杯在线测试题基础题解/" class="archive-article-date">
  	<time datetime="2017-01-31T07:36:31.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-01-31</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-大三时候目标" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/31/大三时候目标/">我的目标记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="2017-04-09"><a href="#2017-04-09" class="headerlink" title="2017/04/09"></a>2017/04/09</h3><p>蓝桥杯已经结束了。考的很差。<br>总结一下：</p>
<ol>
<li>虽然自己觉得自己学习和练习题目的时间广度很长，从2月开始，但是 练习题目远远不够，没有攒积足够的量变去引起质变！如果说以前的算法等级10分的话我是4分，经过这两个月变成了4。对于我这个笨蛋来说，在技术超出平凡的首要手段还是量变引起质变。我的重视程度还是不够，吃亏。</li>
<li>这一场考试，要求的是快速抽象问题，思考问题，解决问题，代码实现。我的考试能力有点下降而且考试的时候太过于紧张，太过于沉浸于题目中，没有冷静思考就开始做题了，然后跳不出来。</li>
</ol>
<p>一直准备进入游戏行业，现在准备自学一下Unity。<br>第一阶段 是把mook网上所有有关unity的视频都自己实现一遍。（完成后打勾：）</p>
<h3 id="2017-01-31"><a href="#2017-01-31" class="headerlink" title="2017/01/31"></a>2017/01/31</h3><p> 不知不觉大学已经到了大三了，第一学期也完了,写一下大三下要完成的目标。希望在大三下的时候有更多的进步，一分耕耘一分收获，谨记此条踏实前行.</p>
<ol>
<li>大三下不挂科,物理也不能挂.</li>
<li>蓝桥杯争取进入国赛。</li>
<li>暑假的时候要学开车考驾照，这个事情不能再拖了。</li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/01/31/大三时候目标/" class="archive-article-date">
  	<time datetime="2017-01-31T07:19:57.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-01-31</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/目标/">目标</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-搭建博客时遇到的问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/30/搭建博客时遇到的问题/">搭建博客时遇到的问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="hexo下的分类和表签无法显示，怎么解决？"><a href="#hexo下的分类和表签无法显示，怎么解决？" class="headerlink" title="hexo下的分类和表签无法显示，怎么解决？"></a>hexo下的分类和表签无法显示，怎么解决？</h3><p>参考了知乎上的解决方案，解决问题.</p>
<ol>
<li>命令行 hexo new page “tags”,就创建了一个tags文件夹并且里面有一个index.md文件.</li>
<li><p>编辑index.md文件，页面内容编辑如下:</p>
<blockquote>
<p>title: tags</p>
<p>date: 2016-11-11 21:40:58</p>
<p>type: “tags”<br>comments: false //这里是关闭评论</p>
</blockquote>
</li>
<li><p>至于后面的menu添加内容我并没有弄，以上做完以上内容我的标签已然可以正常使用.</p>
</li>
</ol>
<h3 id="hexo-ERROR-Deployer-not-found-git"><a href="#hexo-ERROR-Deployer-not-found-git" class="headerlink" title="hexo ERROR Deployer not found: git"></a>hexo ERROR Deployer not found: git</h3><p>解决这个问题需要安装git，配置git的环境变量。然后打开cmd，输入:</p>
<blockquote>
<p>npm install hexo-deployer-git –save</p>
</blockquote>
<p>主配置文件_config.yml下的deploy的type要是git.</p>
<h3 id="YAMLException-cannot-read-a-block-mapping-entry-a-multi-line-key-may-not-be-an-implicit-key-at-line-5-column-1"><a href="#YAMLException-cannot-read-a-block-mapping-entry-a-multi-line-key-may-not-be-an-implicit-key-at-line-5-column-1" class="headerlink" title="YAMLException: cannot read a block mapping entry; a multi line key may not be an implicit key at line 5, column 1"></a>YAMLException: cannot read a block mapping entry; a multi line key may not be an implicit key at line 5, column 1</h3><p>我遇到的这一类问题大多是自己写的博客文件格式不对，少了空格之类的.仔细检查自己写过的地方格式是否正确即可.</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/01/30/搭建博客时遇到的问题/" class="archive-article-date">
  	<time datetime="2017-01-29T16:00:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-01-30</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/博客搭建/">博客搭建</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 晨曦的葬歌
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/C-C/" style="font-size: 17.5px;">C/C++</a> <a href="/tags/Unity/" style="font-size: 15px;">Unity</a> <a href="/tags/博客搭建/" style="font-size: 12.5px;">博客搭建</a> <a href="/tags/基础/" style="font-size: 20px;">基础</a> <a href="/tags/杂记/" style="font-size: 10px;">杂记</a> <a href="/tags/目标/" style="font-size: 10px;">目标</a> <a href="/tags/算法/" style="font-size: 12.5px;">算法</a> <a href="/tags/重装/" style="font-size: 10px;">重装</a>
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">勇敢地做梦，并向着那个梦去奔跑！</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>