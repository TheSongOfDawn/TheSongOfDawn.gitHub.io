<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>Othello&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Othello's Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Othello's Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Othello's Blog">
  
    <link rel="alternative" href="/atom.xml" title="Othello&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="https://avatars2.githubusercontent.com/u/18623875?v=3&amp;s=466" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">晨曦的葬歌</a></h1>
		</hgroup>

		
		<p class="header-subtitle">天上半阴半暗的云</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主 页</a></li>
	        
				<li><a href="/archives">归 档</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/TheSongOfDawn" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/u/3943183234?refer_flag=1001030101_" title="weibo">weibo</a>
		        
					<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/li-ke-19-67" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">晨曦的葬歌</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="https://avatars2.githubusercontent.com/u/18623875?v=3&amp;s=466" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">晨曦的葬歌</h1>
			</hgroup>
			
			<p class="header-subtitle">天上半阴半暗的云</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主 页</a></li>
		        
					<li><a href="/archives">归 档</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/TheSongOfDawn" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/3943183234?refer_flag=1001030101_" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/li-ke-19-67" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-《ThinkingInJava》笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/18/《ThinkingInJava》笔记/">《ThinkingInJava》笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="2017-7-21"><a href="#2017-7-21" class="headerlink" title="2017/7/21"></a>2017/7/21</h3><ol>
<li>HashMap,HashTable区别</li>
</ol>
<p>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。<br>HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。<br>HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。<br>另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。<br>由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。<br>HashMap不能保证随着时间的推移Map中的元素次序是不变的。</p>
<ol>
<li>final,finally,finalize</li>
</ol>
<p>final—修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。<br>finally—再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。<br>finalize—方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。</p>
<ol>
<li>JSP内置对象<br>jsp内置对象<br>定义：可以不加声明就在JSP页面脚本（Java程序片和Java表达式）中使用的成员变量<br>JSP共有以下9种基本内置组件（可与ASP的6种内部组件相对应）：<br>1.request对象<br>客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。<br>序号 方 法 说 明<br>1 object getAttribute(String name) 返回指定属性的属性值<br>2 Enumeration getAttributeNames() 返回所有可用属性名的枚举<br>3 String getCharacterEncoding() 返回字符编码方式<br>4 int getContentLength() 返回请求体的长度（以字节数）<br>5 String getContentType() 得到请求体的MIME类型<br>6 ServletInputStream getInputStream() 得到请求体中一行的二进制流<br>7 String getParameter(String name) 返回name指定参数的参数值<br>8 Enumeration getParameterNames() 返回可用参数名的枚举<br>9 String[] getParameterValues(String name) 返回包含参数name的所有值的数组<br>10 String getProtocol() 返回请求用的协议类型及版本号<br>11 String getScheme() 返回请求用的计划名,如:http.https及ftp等<br>12 String getServerName() 返回接受请求的服务器主机名<br>13 int getServerPort() 返回服务器接受此请求所用的端口号<br>14 BufferedReader getReader() 返回解码过了的请求体<br>15 String getRemoteAddr() 返回发送此请求的客户端IP地址<br>16 String getRemoteHost() 返回发送此请求的客户端主机名<br>17 void setAttribute(String key,Object obj) 设置属性的属性值<br>18 String getRealPath(String path) 返回一虚拟路径的真实路径<br>2.response对象<br>response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。<br>序号 方 法 说 明<br>1 String getCharacterEncoding() 返回响应用的是何种字符编码<br>2 ServletOutputStream getOutputStream() 返回响应的一个二进制输出流<br>3 PrintWriter getWriter() 返回可以向客户端输出字符的一个对象<br>4 void setContentLength(int len) 设置响应头长度<br>5 void setContentType(String type) 设置响应的MIME类型<br>6 sendRedirect(java.lang.String location) 重新定向客户端的请求<br>3.session对象<br>session对象指的是客户端与服务器的一次会话，从客户端连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.<br>序号 方 法 说 明<br>1 long getCreationTime() 返回SESSION创建时间<br>2 public String getId() 返回SESSION创建时JSP引擎为它设的惟一ID号<br>3 long getLastAccessedTime() 返回此SESSION里客户端最近一次请求时间<br>4 int getMaxInactiveInterval() 返回两次请求间隔多长时间此SESSION被取消(ms)<br>5 String[] getValueNames() 返回一个包含此SESSION中所有可用属性的数组<br>6 void invalidate() 取消SESSION，使SESSION不可用<br>7 boolean isNew() 返回服务器创建的一个SESSION,客户端是否已经加入<br>8 void removeValue(String name) 删除SESSION中指定的属性<br>9 void setMaxInactiveInterval() 设置两次请求间隔多长时间此SESSION被取消(ms)<br>4.out对象<br>out对象是JspWriter类的实例,是向客户端输出内容常用的对象<br>序号 方 法 说 明<br>1 void clear() 清除缓冲区的内容<br>2 void clearBuffer() 清除缓冲区的当前内容<br>3 void flush() 清空流<br>4 int getBufferSize() 返回缓冲区以字节数的大小，如不设缓冲区则为0<br>5 int getRemaining() 返回缓冲区还剩余多少可用<br>6 boolean isAutoFlush() 返回缓冲区满时，是自动清空还是抛出异常<br>7 void close() 关闭输出流<br>5.page对象<br>page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例<br>序号 方 法 说 明<br>1 class getClass 返回此Object的类<br>2 int hashCode() 返回此Object的hash码<br>3 boolean equals(Object obj) 判断此Object是否与指定的Object对象相等<br>4 void copy(Object obj) 把此Object拷贝到指定的Object对象中<br>5 Object clone() 克隆此Object对象<br>6 String toString() 把此Object对象转换成String类的对象<br>7 void notify() 唤醒一个等待的线程<br>8 void notifyAll() 唤醒所有等待的线程<br>9 void wait(int timeout) 使一个线程处于等待直到timeout结束或被唤醒<br>10 void wait() 使一个线程处于等待直到被唤醒<br>11 void enterMonitor() 对Object加锁<br>12 void exitMonitor() 对Object开锁<br>6.application对象</li>
</ol>
<p>application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。<br>序号 方 法 说 明<br>1 Object getAttribute(String name) 返回给定名的属性值<br>2 Enumeration getAttributeNames() 返回所有可用属性名的枚举<br>3 void setAttribute(String name,Object obj) 设定属性的属性值<br>4 void removeAttribute(String name) 删除一属性及其属性值<br>5 String getServerInfo() 返回JSP(SERVLET)引擎名及版本号<br>6 String getRealPath(String path) 返回一虚拟路径的真实路径<br>7 ServletContext getContext(String uripath) 返回指定WebApplication的application对象<br>8 int getMajorVersion() 返回服务器支持的Servlet API的最大版本号<br>9 int getMinorVersion() 返回服务器支持的Servlet API的最大版本号<br>10 String getMimeType(String file) 返回指定文件的MIME类型<br>11 URL getResource(String path) 返回指定资源(文件及目录)的URL路径<br>12 InputStream getResourceAsStream(String path) 返回指定资源的输入流<br>13 RequestDispatcher getRequestDispatcher(String uripath) 返回指定资源的RequestDispatcher对象<br>14 Servlet getServlet(String name) 返回指定名的Servlet<br>15 Enumeration getServlets() 返回所有Servlet的枚举<br>16 Enumeration getServletNames() 返回所有Servlet名的枚举<br>17 void log(String msg) 把指定消息写入Servlet的日志文件<br>18 void log(Exception exception,String msg) 把指定异常的栈轨迹及错误消息写入Servlet的日志文件<br>19 void log(String msg,Throwable throwable) 把栈轨迹及给出的Throwable异常的说明信息 写入Servlet的日志文件<br>7.exception对象<br>exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象<br>序号 方 法 说 明<br>1 String getMessage() 返回描述异常的消息<br>2 String toString() 返回关于异常的简短描述消息<br>3 void printStackTrace() 显示异常及其栈轨迹<br>4 Throwable FillInStackTrace() 重写异常的执行栈轨迹<br>8.pageContext对象<br>pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本类名也叫pageContext。<br>序号 方 法 说 明<br>1 JspWriter getOut() 返回当前客户端响应被使用的JspWriter流(out)<br>2 HttpSession getSession() 返回当前页中的HttpSession对象(session)<br>3 Object getPage() 返回当前页的Object对象(page)<br>4 ServletRequest getRequest() 返回当前页的ServletRequest对象(request)<br>5 ServletResponse getResponse() 返回当前页的ServletResponse对象(response)<br>6 Exception getException() 返回当前页的Exception对象(exception)<br>7 ServletConfig getServletConfig() 返回当前页的ServletConfig对象(config)<br>8 ServletContext getServletContext() 返回当前页的ServletContext对象(application)<br>9 void setAttribute(String name,Object attribute) 设置属性及属性值<br>10 void setAttribute(String name,Object obj,int scope) 在指定范围内设置属性及属性值<br>11 public Object getAttribute(String name) 取属性的值<br>12 Object getAttribute(String name,int scope) 在指定范围内取属性的值<br>13 public Object findAttribute(String name) 寻找一属性,返回起属性值或NULL<br>14 void removeAttribute(String name) 删除某属性<br>15 void removeAttribute(String name,int scope) 在指定范围删除某属性<br>16 int getAttributeScope(String name) 返回某属性的作用范围<br>17 Enumeration getAttributeNamesInScope(int scope) 返回指定范围内可用的属性名枚举<br>18 void release() 释放pageContext所占用的资源<br>19 void forward(String relativeUrlPath) 使当前页面重导到另一页面<br>20 void include(String relativeUrlPath) 在当前位置包含另一文件<br>9.config对象<br>config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）<br>序号 方 法 说 明<br>1 ServletContext getServletContext() 返回含有服务器相关信息的ServletContext对象<br>2 String getInitParameter(String name) 返回初始化参数的值<br>3 Enumeration getInitParameterNames() 返回Servlet初始化所需所有参数的枚举</p>
<ol>
<li>表连接,左右内连接<br>联接可分为以下几类：<br>1、内联接（典型的联接运算，使用像 =  或 &lt;&gt; 之类的比较运算符）。包括相等联接和自然联接。<br>内联接使用比较运算符根据每个表共有的列的值匹配两个表中的行。例如，检索 students和courses表中学生标识号相同的所有行。   </li>
</ol>
<p>2、外联接。外联接可以是左向外联接、右向外联接或完整外部联接。<br>在 FROM子句中指定外联接时，可以由下列几组关键字中的一组指定：     </p>
<p>1）LEFT  JOIN或LEFT OUTER JOIN<br>左向外联接的结果集包括  LEFT OUTER子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。       </p>
<p>2）RIGHT  JOIN 或 RIGHT  OUTER  JOIN<br>右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。<br>3）FULL  JOIN 或 FULL OUTER JOIN<br>完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。   </p>
<p>3、交叉联接<br>交叉联接返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积。    </p>
<p>FROM 子句中的表或视图可通过内联接或完整外部联接按任意顺序指定；但是，用左或右向外联接指定表或视图时，表或视图的顺序很重要。有关使用左或右向外联接排列表的更多信息，请参见使用外联接。     </p>
<ol>
<li>什么是事务？什么是锁？</li>
</ol>
<p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。<br>事务具有原子性，一致性，隔离性，持久性。<br>原子性：事务必须是一个自动工作的单元，要么全部执行，要么全部不执行。<br>一致性：事务结束的时候，所有的内部数据都是正确的。<br>隔离性：并发多个事务时，各个事务不干涉内部数据，处理的都是另外一个事务处理之前或之后的数据。<br>持久性：事务提交之后，数据是永久性的，不可再回滚。</p>
<p>锁是指一个事务对每个数据对象进行操作时，需要对数据对象加对应锁。这样其他事务最此数据对象访问就受限。当操作结束后事务释放此锁。</p>
<ol>
<li><p>NIO<br>参考：<a href="http://ifeve.com/overview/" target="_blank" rel="external">http://ifeve.com/overview/</a><br>Java NIO 由以下几个核心部分组成：<br>Channels<br>Buffers<br>Selectors<br>Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
</li>
<li><p>Java8新特性</p>
</li>
</ol>
<p>参考:<a href="http://www.importnew.com/11908.html" target="_blank" rel="external">http://www.importnew.com/11908.html</a></p>
<ol>
<li>==和equals（）</li>
</ol>
<p>==，比较的是一个对象在内存中的地址值，<br>equals的情况比较复杂，它是java.lang.Object类中的一个方法。因为java中所有的类都默认继承于Object，所以所有的类都有这个方法。<br>在Object类源码中是这样写的。</p>
<pre><code>public boolean equals(Object obj) {
return (this == obj);
}
他同样使用==号进行内存地址的比较。但是许多java类中都重写了这个方法，比如String。
public boolean equals(Object anObject) {
if (this == anObject) {
return true;
}
if (anObject instanceof String) {
String anotherString = (String)anObject;
int n = count;
if (n == anotherString.count) {
char v1[] = value;
char v2[] = anotherString.value;
int i = offset;
int j = anotherString.offset;
while (n-- != 0) {
if (v1[i++] != v2[j++])
return false;
}
return true;
}
}
return false;
}
</code></pre><p>String里的方法，如果==号比较不相等，还会进行一下值的比较。<br>所以equals方法具体的作用要看当前的那个类是如何实现重写父类中该方法的。如果没有重写该方法，那么他和==号等价。</p>
<ol>
<li><p>线程的几种使用方式？你喜欢哪一种，为什么？</p>
<pre><code>Java多线程实现方式主要有三种：继承Thread类、实现Runnable接口、使用ExecutorService、Callable、Future实现有返回结果的多线程。其中前两种方式线程执行完后都没有返回值，只有最后一种是带返回值的。
</code></pre></li>
<li><p>写出下面两个代码的输出:</p>
<pre><code>//面试中遇到的一个代码题
public class ms1 {

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        Integer f1=100,f2=100,f3=150,f4=150;

        System.out.println(f1==f2);
        System.out.println(f3==f4);
    }
    /*output:
     * true
     * false
     * 
     * 1.==在比较对象类型的时候是比较地址值的
     * 2.Integer有一个常量池在-128~127的时候，
     * 生成的Integer对象是同一个地址值，所以为true
     * 当超过这个范围产生的就是不同的对象，所以用==比较为false
     * */
}

//面试代码题题2
public class ms2 {

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        System.out.println(f());

    }
    static boolean f() {
        try {
//            System.out.println(&quot;try中....&quot;);
//            System.exit(0); 如果程序中断了，就只会执行到这里不会进行下一步
            return true;

        } finally {
            System.out.println(&quot;finally中....&quot;);
            return false;
        }
    }
}
/*output
 * false
 * 因为finally只要不中断程序就一定会执行。。。。  
 *栈中先放入true,然后栈中再放入false,然后就返回栈中的第一个了  
 * 
 * Return并不是让函数马上返回
 * 而是return语句执行后，
 * 将把返回结果放置进函数栈中，
 * 此时函数并不是马上返回，
 * 它要执行finally语句后才真正开始返回。
 * */
</code></pre></li>
<li><p>为什么ArrayL查找快，增删慢</p>
<p>arraylist类似于数组形式，数据只要给定索引就可以直接得到数字，arraylist也一样，但是如果要增删，就要移动后面的说有元素，这样就慢了，而linklist是使用类似于链表来存储的，与arraylist相反，增删只要添加一个连接就可以了，不要移动后面的所有元素</p>
</li>
<li><p>protected，private,public与默认的区别</p>
<pre><code>         作用域    当前类  同包 子类 其他

public        √        √       √      √

protected  √        √       √      ×

默认           √       √       ×      ×

private       √        ×      ×      ×
</code></pre><p>类的成员不写访问修饰时默认为default。默认对于同一个包中的其他类相当于公开（public），对于不是同一个包中的其他类相当于私有（private）。受保护（protected）对子类相当于公开，对不是同一包中的没有父子关系的类相当于私有。</p>
<p>Java中访问修饰符public、private、protecte、default的意义讲解：<br>public（接口访问权限）： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包（package）访问。<br>private（你无法访问）: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。<br>protected（继承访问权限）: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。<br>default（包访问权限）：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访问。 </p>
</li>
<li><p>“static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？<br>Static表示静态的意思，可用于修饰成员变量和成员函数，被静态修饰的成员函数只能访问静态成员，不可以访问非静态成员。静态是随着类的加载而加载的，因此可以直接用类进行访问。 重写是子类中的方法和子类继承的父类中的方法一样（函数名，参数，参数类型，反回值类型），但是子类中的访问权限要不低于父类中的访问权限。重写的前提是必须要继承，private修饰不支持继承，因此被私有的方法不可以被重写。静态方法形式上可以被重写，即子类中可以重写父类中静态的方法。但是实际上从内存的角度上静态方法不可以被重写。</p>
</li>
<li><p>用递归来写斐波那契数列</p>
<pre><code>package com.lk.thread;

import java.util.Scanner;

public class test {
    public static int result(int n) {
        if (n == 1 || n == 2) {
            return 1;
        }
        return result(n - 1) + result(n - 2);
    }

    public static &lt;result&gt; void main(String[] args) {
        System.out.println(&quot;Input Number：&quot;);
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        for (int i = 1; i &lt; n; i++) {
            System.out.print(result(i) + &quot; &quot;);
        }
    }
}
</code></pre></li>
<li><p>java中float,double利用BigDecimal运算的区别<br>参考：<a href="https://yq.aliyun.com/articles/19371" target="_blank" rel="external">https://yq.aliyun.com/articles/19371</a><br>参考2：<a href="http://blog.csdn.net/yztezhl/article/details/18699319" target="_blank" rel="external">http://blog.csdn.net/yztezhl/article/details/18699319</a><br>float、double两种基本类型在运算的时候容易引起精度丢失。</p>
</li>
<li>javaweb中基本框架<br>参考：<a href="http://www.cnblogs.com/byqh/p/5595384.html" target="_blank" rel="external">http://www.cnblogs.com/byqh/p/5595384.html</a></li>
<li><p>java有什么模板引擎</p>
<p>引自百度：<br> 模板引擎就是用于制作页面模板的。啥是模板？不就是做好模子，然后套入数据，就成一个产品了吗？模板引擎有很多，常用的有freemarker、velocity等。它们都有自己的语法，只为简化页面数据展示。只要你稍微了解一下freemarker，就能很好的理解什么是模板了。</p>
<h3 id="2017-7-19"><a href="#2017-7-19" class="headerlink" title="2017/7/19"></a>2017/7/19</h3></li>
<li>java中可以将一个数组赋值给另一个数组，其实真正做的只是一个引用，两个引用都指向的同一块内存。通过两个引用都可以修改数组内的值.</li>
<li>取得某类成员的访问权的唯一途径是：<ol>
<li>使该成员成为public</li>
<li>通过不加访问权限修饰词并将其他类放置于同一个包内的方式给成员赋予包访问权</li>
<li>继承。继承的类可以访问public protected 但不能访问private</li>
<li>提供访问器和变异器(gt/set方法)</li>
</ol>
</li>
<li>任何可以肯定只是一个该类的一个助手方法的方法，都可以把它指定为private<h3 id="2017-7-18"><a href="#2017-7-18" class="headerlink" title="2017/7/18"></a>2017/7/18</h3></li>
<li><p>Foreach语法 表示不必创建int变量去对由访问项构成的序列进行计数，foreach将自动产生每一项。</p>
</li>
<li><p>return：一方面指定一个方法返回什么值，另一方面会导致当前的方法退出，并返回那个值</p>
</li>
<li><p>switch(){case integral-value:statement;break;}</p>
</li>
<li>this关键字.this关键字只能在方法内部使用，表示对 调用方法的那个对象的 引用。比如，当需要返回对当前对象的引用，常常在写 return this.            </li>
<li>清理：对象可能不被垃圾回收；垃圾回收并不等于析构；垃圾回收只与内存有关</li>
<li>垃圾回收的存在不能完全代替析构函数，而且绝对不嗯呢该直接调用finalize();无论是垃圾回收还是终结，都不保证一定会发生。如果jvm并未面临内存耗尽的情况，它是不会浪费时间去执行垃圾回收以恢复内存的。                                                                          </li>
</ol>
<h3 id="2017-7-17"><a href="#2017-7-17" class="headerlink" title="2017/7/17"></a>2017/7/17</h3><ol>
<li>尽管Java是基于C++的，但Java是一种更纯粹的面向对象程序设计(OOP)语言。</li>
<li>一切被视为对象！操作的标识符实际上是对对象的一个 引用</li>
<li>New 的意思是 给我一个新对象</li>
<li>对象存储在堆中。（寄存器，堆栈（对象引用存在其中），堆，常量存储，非ARM存储)</li>
<li>基本类型是不用new来创建的 ，而是创建一个并非是引用的自动变量。这个变量直接存储值，并放置在堆栈中。</li>
<li>基本类型 大小-包装器类型:boolean-Boolean,char 16 bits-Character,byte 8 bits-Byte,short 16 bits-Short,int 32 bits-Integer,long 64 bits-Long,float 32 bits-Float,double 64 bits-Double,void-Void </li>
<li>高精度数字 BigInteger 和BigDecimal</li>
<li>常用注释方式 //和/<strong>/ 文档注释/</strong> */</li>
<li>标签实例:<br> 1.@see classname/@see full-qualified-class/@see fully-fully-qualified-classname#method-name引用其他类 ，加入一个具有超链接的条目<br> 2.{@link package.class#member label}用于行内 并是用label作为超链接文本<br> 3.{@docRoot} 该标签产生到文档根目录的相对路径，用于文档树页面的显式超链接<br> 4.@version version-information 版本信息<br> 5.@author author-info<br> 6.{@inheritDoc}从当前这个类最直接的基类中继承相关文档到当前的文档注释中<br> 7.@since 允许指定程序代码最早使用的版本<br> 8.@param parameter-name description 残生标识符<br> 9.@return description 用来描述返回值的含义，可以延续数行<br> 10.@throws fully-qualified-class-name description 异常<br> 11.deprecated 指出一些旧特性已由新特性取代 建议用户不要使用这些旧特性 </li>
<li>编码风格 类名大驼峰，其余的小驼峰</li>
<li>Java在进行一个浮点数转化为Int型时候，总是对改数字执行截尾操作。如果想要对数字进行四舍五入操作，就需要使用java.Math.round方法()。</li>
<li>Math库里静态方法grandom(),产生[0,1)之间的一个double值</li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/07/18/《ThinkingInJava》笔记/" class="archive-article-date">
  	<time datetime="2017-07-18T08:50:25.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-07-18</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-使用Github遇到的问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/16/使用Github遇到的问题/">使用Github遇到的问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 参考过的文章：<a href="http://www.cnblogs.com/specter45/p/github.html" target="_blank" rel="external">http://www.cnblogs.com/specter45/p/github.html</a></p>
<h3 id="Q1-Not-a-git-repository-or-any-of-the-parent-directories-git"><a href="#Q1-Not-a-git-repository-or-any-of-the-parent-directories-git" class="headerlink" title="Q1: Not a git repository (or any of the parent directories): .git"></a>Q1: Not a git repository (or any of the parent directories): .git</h3><pre><code>这说明你当前的路径并不是一个git库，必须进入到库对应的文件夹内，git的大部分命令才有效.cd进入特定的仓库再进行操作.
</code></pre><p>创建新仓库的指令：</p>
<pre><code>git init //把这个目录变成Git可以管理的仓库
git add README.md //文件添加到仓库
git add . //不但可以跟单一文件，还可以跟通配符，更可以跟目录。一个点就把当前目录下所有未追踪的文件全部add了 
git commit -m &quot;first commit&quot; //把文件提交到仓库
git remote add origin git@github.com:wangjiax9/practice.git //关联远程仓库
git push -u origin master //把本地库的所有内容推送到远程库上
</code></pre><p>执行指令添加文件-&gt;提交文件-&gt;推送文件<br>git add .</p>
<p>git commit -m “提交test1.html”</p>
<p>git push -u origin master<br>执行完成后就可以在网上GitHub上看到相应的变化了</p>
<h3 id="Q2-在网页端修改了README-md后没有及时更新本地thinkinginjava仓库，不能使用git-push"><a href="#Q2-在网页端修改了README-md后没有及时更新本地thinkinginjava仓库，不能使用git-push" class="headerlink" title="Q2:在网页端修改了README.md后没有及时更新本地thinkinginjava仓库，不能使用git push"></a>Q2:在网页端修改了README.md后没有及时更新本地thinkinginjava仓库，不能使用git push</h3><p> 先git pull 更新本地分支 然后再push到云端<br>引伸：</p>
<pre><code>Git中从远程的分支获取最新的版本到本地有这样2个命令：
1. git fetch：相当于是从远程获取最新版本到本地，不会自动merge
Git fetch origin master
git log -p master..origin/master
git merge origin/master

以上命令的含义：
首先从远程的origin的master主分支下载最新的版本到origin/master分支上
然后比较本地的master分支和origin/master分支的差别
最后进行合并
上述过程其实可以用以下更清晰的方式来进行：
git fetch origin master:tmp
git diff tmp 
git merge tmp

从远程获取最新的版本到本地的test分支上
 之后再进行比较合并
2. git pull：相当于是从远程获取最新版本并merge到本地
 git pull origin master

上述命令其实相当于git fetch 和 git merge
在实际使用中，git fetch更安全一些
因为在merge前，我们可以查看更新情况，然后再决定是否合并
</code></pre><h3 id="Q3：当我要删除一个存在的目录或者文件夹时"><a href="#Q3：当我要删除一个存在的目录或者文件夹时" class="headerlink" title="Q3：当我要删除一个存在的目录或者文件夹时"></a>Q3：当我要删除一个存在的目录或者文件夹时</h3><pre><code>本地删除该文件夹后，要git add -A 才行，而不能够只使用git add .号，然后再继续后面的操作
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/07/16/使用Github遇到的问题/" class="archive-article-date">
  	<time datetime="2017-07-16T15:43:25.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-07-16</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GitHub/">GitHub</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/">git</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-大学里写的总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/12/大学里写的总结/">大学里写的总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="2017-07-12"><a href="#2017-07-12" class="headerlink" title="2017/07/12"></a>2017/07/12</h3><p>现在是大三下完结了。忽然想写一学期的总结，看看自己一学期干了些啥子东西,而且准备以后每一学期过完也写一个总结，仅剩俩学期。MD要大四了，有点小方。</p>
<p>看的书有：《西游记》，《巨人的陨落》。看的书很少，看的知乎却变多了。<br>有时候也跑跑步锻炼，也去图书馆。都没有坚持下来。<br>开学到期中以前是在搞蓝桥杯比赛的准备，xjbz，然后4月份又又tm忍不了我要进军游戏界当大佬，网上搜索课程，把u3d游戏引擎的基础学了。然后觉得自己牛逼了，就又丢了。然后蓝桥杯比赛，比赛完拖了几天就去报名学车了。<br>学车是从4.15号学的，然后到今天拿证，差不多三个月，贯穿了后半个学期吧。<br>6月7号觉得游戏方面的技能点不够啊，又开始点计算机图形学和u3d进阶，结果没坚持几天遇到大作业周就开始写大作业，直到今天没摸一下这两个技能点。<br>PS：6月份的时候没有玩lol，很好。</p>
<p>关于大作业周</p>
<pre><code>javaee的大作业是认认真真的完成的，写了5天，一边看书，一边网上找代码，消化掉然后写出自己想要的东西，达到功能全实现了。写完以后真的感觉很棒。但是界面很简陋，后来也没有改进。
h5的大作业是当的小组长，总结一下就是我实在太他妈能拖了太他妈的辣鸡了。我现在简直后悔选这门课，专门来打击自己的自信心吗？第一个大作业是写一个关于学校某个自定义主题的网页，女生组写完以后我和fw，zys连tm的素材都还没有去找？汪汪汪，抽自己一个大耳瓜子。到最后就赶工，写的很垃圾，交的时候都还有错。然后写第二个游戏，我认真写了需求分析，以为我们可以弄个源码分享，大家写出各自的功能块，互相说明功能块是什么作用，然后组装就行了，然后他们说一人写一关？汪汪汪？平日里装瓜皮，关键时刻也被人当瓜皮。当时应该固执己见的，不然就不会打击到自己了，也是怪自己太高看自己了。对这大作业就根本不上心，老想着最后来补，结果最后也没补。敷衍了事。（但还是要感谢同学们完成大作业）唉！周围的人上课耍手机不听课我也学？我真棒（辣鸡）。回想这门课，我除了知道一个canvas还知道了啥呢？都是以前的知识啊！
C#大作业写的超市管理库存模块，感觉就是照抄老师的代码。对不起老师我那两天老是想过我的科目二，以至于不情愿的缺席了几节课，到后来我是真的跟不上老师写的代码，您写的太快。。。写项目的时候，跟队友沟通的还可以，但我觉得数据库应该大家一起设计好以后再做会更好点。自点一个 把写项目的时候遇到的问题都写在一个文档里，写完项目了收获大纲也有了。
</code></pre>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/07/12/大学里写的总结/" class="archive-article-date">
  	<time datetime="2017-07-12T11:01:20.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-07-12</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/总结/">总结</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-基于Unity引擎的游戏开发基础-课程笔记5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/04/基于Unity引擎的游戏开发基础-课程笔记5/">基于Unity引擎的游戏开发基础-课程笔记5</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="GUI介绍"><a href="#GUI介绍" class="headerlink" title="GUI介绍"></a>GUI介绍</h3><p>GUI是Graphical User Interface（图形用户界面）的简称，是一种人与计算机通信的界面显示格式。它允许用户使用鼠标等输入设备操纵屏幕上的图标或菜单选项，以选择命令，调用文件，启动程序或执行一些其他日常任务。</p>
<p>在游戏开发过程中，游戏界面设计具有非常重要的作用，玩家打开游戏后第一个接触的游戏元素，通常是游戏的GUI。游戏的GUI是否友好，美观，在很大程度上影响玩家的游戏体验</p>
<p>4.6版本以后</p>
<p>###　uGUI介绍<br>与Unity引擎紧密的结合<br>灵活 快速 可视化编程技术<br>更加强大与易用的屏幕自适应能力<br>全新的布局系统<br>简单易用的UI控件<br>强大的事件处理系统</p>
<h4 id="uGUI-控件的创建步骤"><a href="#uGUI-控件的创建步骤" class="headerlink" title="uGUI 控件的创建步骤"></a>uGUI 控件的创建步骤</h4><p>在 Hierarchy 视图中 点击鼠标右键，选择 UI 中的 uGUI 控件 即可完成 uGUI 控件的创建</p>
<h4 id="Canvas与EventSystem"><a href="#Canvas与EventSystem" class="headerlink" title="Canvas与EventSystem"></a>Canvas与EventSystem</h4><p>Canvas表示画布，是uGUI控件的容器，uGUI控件必须是Canvas的子对象<br>EvenSystem是事件处理系统，用于处理与响应用户与uGUI的交互</p>
<p>Canvas中的对象绘制：靠上的对象先绘制</p>
<p>Sort Order（表示Canvas之间绘制顺序） 该值越小的Canvas越先绘制</p>
<h4 id="Anchor（锚点）"><a href="#Anchor（锚点）" class="headerlink" title="Anchor（锚点）"></a>Anchor（锚点）</h4><p>Anchor（锚点）是一种相对定位技术，每个控件都有各自的锚点。<br>我们可以先将锚点设置在屏幕的某个位置，然后设置其相对锚点的位置，这样可以方便的控制uGUI控件的位置。</p>
<h4 id="uGUI控件介绍"><a href="#uGUI控件介绍" class="headerlink" title="uGUI控件介绍"></a>uGUI控件介绍</h4><h5 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h5><pre><code>Text文本内容；Font：字体样式；Font Style 字体风格；FontSize 字体大小 Line Spacing：行间距
Alignment 对齐方式 Color 文字颜色 Material 文字材质
</code></pre><h5 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h5><p>Image 控件用于在图形界面上绘制出一个图像 例如角色头像、 射击准星等<br>    Source Image：图像源<br>    Color图像显示的颜色<br>    Material：材质</p>
<h5 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h5><p>在Unity中创建的Button控件是复合控件，包括Button背景图案，Button按钮功能以及Button文本信息<br>    在 On Click中设置点击响应事件<br>Button事件设置流程<br>    编写Button按钮触发的事件函数；<br>    将包含该函数的脚本添加到场景中的任意一个游戏对象中；<br>    在Button组件的OnClick中添加事件函数（注意 ：只有修饰符为public的函数才能被Button按钮调用）</p>
<h5 id="InputField"><a href="#InputField" class="headerlink" title="InputField"></a>InputField</h5><pre><code>在Unity中创建的InputField控件是复合控件，包括输入栏背景图案，输入栏组件，输入栏提示以及输入栏可编辑文本
Text Component 表示输入框 可编辑的 Text 组件，Text 组件原本不可以在游戏中编辑 只有把 Text 组件赋给 InputField 组件    的 Text Component 属性，我们才可以在游戏中编辑 Text 组件
laceholder 表示输入框中，用于显示提示信息的 Text 组件
</code></pre><h5 id="Slider"><a href="#Slider" class="headerlink" title="Slider"></a>Slider</h5><pre><code>在Unty中创建的Slider控件是复合控件，它包含
滑动条背景（Background），滑动条填充图案（Fill Area），滑动块手柄（Handle Slider Area）
</code></pre><h5 id="常用属性："><a href="#常用属性：" class="headerlink" title="常用属性："></a>常用属性：</h5><pre><code>Fill Rect:滑动条填充图案
Handle Rect:滑动条上的滑块图案
Direction：数值增加的方向
Min/Max Value：滑动条的最小/最大值
</code></pre><h5 id="Toggle"><a href="#Toggle" class="headerlink" title="Toggle"></a>Toggle</h5><pre><code>表示开关控件，它包含勾选框背景（Background），勾选图案（Checkmark）以及Toggle文本信息（Label）
</code></pre><p>常用属性<br>    Is On：Toggle是否勾选<br>    Graphic：设置Toggle背景图案<br>    OnValueChanged：当Toggle勾选情况发生改变时对应的事件响应函数</p>
<p>用了6节时间来教授如何制作uGUI控件 实践课</p>
<h3 id="移动平台触摸控制的实现方式"><a href="#移动平台触摸控制的实现方式" class="headerlink" title="移动平台触摸控制的实现方式"></a>移动平台触摸控制的实现方式</h3><ol>
<li>使用Input移动端输入函数，完成移动端输入的读取</li>
<li>用Cross Platform Input资源包快速实现跨平台输入UI</li>
</ol>
<h4 id="Cross-Platform-Input"><a href="#Cross-Platform-Input" class="headerlink" title="Cross Platform Input"></a>Cross Platform Input</h4><p>Cross Platform Input是Unity Standard Assets中的跨平台输入控制资源，它包含移动端常用的控制UI与控制脚本<br>开发者可以使用这些资源实现移动端控制UI的开发</p>
<p>Cross Platform Input 的资源包的导入步骤<br> Project 视图中点击鼠标右键，选择 Import Package 菜单项目中的 CrossPlatformInput，即可完成 Cross Platform Input 资源包的导入</p>
<p>使用 Cross Platform Input制作移动端控制UI的流程</p>
<ol>
<li><p>将Unity编辑平台更改为Android平台<br> 点击 File 菜单栏中的 Build Settings 打开项目构建界面 把平台更改为安卓平台，并点击 Switch Platform 按钮 即可完成安卓平台的切换</p>
</li>
<li><p>向场景中添加Mobile CortrolRig脚本<br> 在场景视图中，创建 Canvas 对象 把 Canvas 对象重命名为 MobileControlCanvas，表示移动端控制画布 我们把 MobileControlRig 脚本绑定到 MobileControlCanvas 中 该脚本是移动端 UI 输入事件的控制器</p>
</li>
<li>在场景中添加用于接受移动端输入的UI对象</li>
<li>给UI对象绑定Cross Platform Input中的脚本，用于获取移动端输入</li>
<li>根据获取的输入在角色控制脚本中实现对玩家的控制</li>
</ol>
<h4 id="移动平台的-UI-适配"><a href="#移动平台的-UI-适配" class="headerlink" title="移动平台的 UI 适配"></a>移动平台的 UI 适配</h4><p>当项目运行平台的屏幕尺寸与分辨率发生变化时，UI 元素会发生缩放 在画布对象中的 Canvas Scale 的组件中，我们可以设置 UI 的缩放模式</p>
<p>第一种可选参数是 Constant Pixel Size，</p>
<p>第二种可选参数是 Scale With Screen Sizse<br>第三种可选参数是 Constant Physical Size，第三种参数中 Constant Physical Size 表示固定物理尺寸，在这种缩放模式下 UI 元素保持固定的物理大小</p>
<h3 id="粒子系统（Particle-System）"><a href="#粒子系统（Particle-System）" class="headerlink" title="粒子系统（Particle System）"></a>粒子系统（Particle System）</h3><p>粒子是在三维空间中渲染出来的二维图像，用于表现如爆炸，烟，火，水等效果</p>
<h4 id="Unity的-Shuriken粒子系统"><a href="#Unity的-Shuriken粒子系统" class="headerlink" title="Unity的 Shuriken粒子系统"></a>Unity的 Shuriken粒子系统</h4><p>Shuriken粒子系统采用模块化的管理方式，使用个性化的粒子模块配合粒子曲线编辑器，使用户更容易创作出各种缤纷复杂的粒子效果</p>
<h4 id="创建粒子系统"><a href="#创建粒子系统" class="headerlink" title="创建粒子系统"></a>创建粒子系统</h4><p>在 Hierarchy 视图中，点击鼠标右键，选择 Particle System，即可完成粒子系统的创建<br>可以在场景中看到粒子系统的初始效果 在 Hierarchy 视图中，点击粒子系统对象 我们发现场景视图中的粒子系统开始播放动画 同时在场景视图的右下角出现了 Particle Effect 它表示粒子系统效果控制器</p>
<p>Pause 用于控制粒子系统的播放与暂停<br>Stop 按钮用于停止粒子系统的播放<br>layback Speed 表示粒子系统的播放速度<br>Playback Time 表示粒子系统的播放时间。<br>Particle Count 表示粒子系统包含的粒子个数</p>
<p>粒子系统示例–简易喷泉</p>
<p>粒子系统初始化模块</p>
<p>Start Lifetime（粒子初始存活时间)-&gt;Random<br>Between Two Constants：0.5~4</p>
<p>Start Speed（粒子初始速度）-&gt;Random<br>Between Two Constants：9~10</p>
<p>Start Size（粒子初始大小）-&gt;Random<br>Between Two Constants：0.1~0.3</p>
<p>Start Rotation（粒子初始朝向）-&gt;Random<br>Between Two Constants：-180~180</p>
<p>Gravity（重力）-&gt;1<br>Max Particales（粒子最大个数）-&gt;10000</p>
<p>Emission（发射模块）<br>Emission（发射模块）<br>    Rate（粒子发射速率）-&gt;5000</p>
<p>Shape（形状模块）<br>Shape：形状模块</p>
<ul>
<li>Shape（粒子喷射形状）-&gt;Cone</li>
<li>Angle（Cone角度）-&gt;10</li>
<li>Radius（Cone底部半径）-&gt;0.3</li>
</ul>
<p>ColorOverLifetime（粒子生命周期颜色模块）<br>勾选ColorOverLifetime 粒子生命周期颜色模块<br>Color（粒子颜色）-&gt;Gradient；Gradient，梯度变化的方式<br>初始颜色：（R，G,B）-&gt;(0,200,255)<br>末尾颜色：（R，G,B）-&gt;(0,255,255)</p>
<p>SizeOverLifetime（粒子生命周期尺寸模块）<br>勾选SizeOverLifetime（粒子生命周期尺寸模块）</p>
<p>Size-&gt;Random Between Two Curves<br>曲线设置：一条从1.0到0.5，另一条从0.8到0.0</p>
<p>在慕课英雄FPS中应用的粒子系统<br>场景中火焰粒子效果：持续播放<br>枪械开火粒子效果：玩家开枪时播放<br>敌人流血粒子效果：敌人受伤时播放</p>
<p>线渲染器 Line Renderer 使用一组 3D 点，在相邻两点之间使用材质绘制一条线 渲染器实现了项目中，枪械激光效果</p>
<h4 id="线渲染器组件的添加步骤"><a href="#线渲染器组件的添加步骤" class="headerlink" title="线渲染器组件的添加步骤"></a>线渲染器组件的添加步骤</h4><p>选择需要添加线渲染器的游戏对象 点击 Component 菜单，选择 Effects 下面的 Line Renderer 即可完成线渲染器的添加</p>
<p>Materials，表示线渲染器绘制所使用的材质</p>
<p> Positions 属性 Size 表示线渲染器 3D 点的个数 Element 表示 3D 点的位置，Size 值为 2 表示接下来需要设置两个 3D 点，线渲染 器以这两个 3D 点为首末端点，Size 值为 3 表示接下来需要设置 3 个 3D 点的位置 线渲染器依次连接两个相邻的 3D 点 完成线渲染器的绘制</p>
<p>Parameters 参数设置 包括线渲染器首尾宽度和首尾颜色的设置<br>start width:始端宽度<br>end width:末端宽度<br>start color：始端颜色<br>end color：末端颜色</p>
<p>如何解决 近大远小 造成的枪械激光粗细不均<br>由摄像机的投影方式：透视引起<br>如何确定枪械激光的末端位置<br>玩家开枪击中物体，我们将枪械激光的末端位置，设置为玩家开枪击中物体的位置。<br>玩家开枪未击中物体，我们将枪械激光的末端位置，设置为子弹攻击实效的位置</p>
<h3 id="物品收集"><a href="#物品收集" class="headerlink" title="物品收集"></a>物品收集</h3><p>草地上有血瓶，主教接近血瓶时，将收集血瓶并实现回血功能</p>
<h4 id="血瓶收集的逻辑"><a href="#血瓶收集的逻辑" class="headerlink" title="血瓶收集的逻辑"></a>血瓶收集的逻辑</h4><p> 首先是玩家接近血瓶，我们给物体设置触发器 使用 OnTriggerEnter 函数，实现玩家接近血瓶的检测，其次是玩家加血 我们访问玩家 player health 脚本中的 health 字段，实现玩家生命值的增加 这里需要注意，加血后玩家的生命值不能超过玩家满血的生命值 然后是播放音频，我们使用 AudioSource 类的 PlayClipAtPoint 函数播放收集音效 这是删除收集物，我们使用 GameObject 类中的 Destrory 函数，实现收集物的删除</p>
<h4 id="游戏胜利画面"><a href="#游戏胜利画面" class="headerlink" title="游戏胜利画面"></a>游戏胜利画面</h4><p>当玩家获得指定的分数后，游戏结束，此时将进入游戏胜利画面：<br>1.删除场景中的敌人与玩家枪械<br>2.游戏结束摄像机从玩家视角平移到天空，俯视地面</p>
<h4 id="游戏失败画面"><a href="#游戏失败画面" class="headerlink" title="游戏失败画面"></a>游戏失败画面</h4><p>当玩家生命值小于等于0时，游戏结束，此时将进入游戏失败画面：</p>
<ol>
<li><p>删除场景中的敌人与玩家枪械<br>我们使用 GameObject 类的 FindGameObjectWithTag 函数 根据敌人标签 Enemy 获取场景中所有敌人对象 保存在敌人数组中，我们使用 foreach 语句快速便利 敌人数组，使用 GameObject 类的 Destroy 函数逐一删除场景中的所有敌人 我们根据 GameObject 类的 Find 函数 根据玩家枪械的名称 Gun 获取场景中的枪械对象，同时使用 GameObject 类的 Destroy 函数 删除枪械对象</p>
</li>
<li><p>游戏结束摄像机从玩家视角平移到天空，俯视地面</p>
</li>
<li><p>屏幕瞬间变黑，然后逐渐恢复正常；<br>我们定义 darkImage 字段 表示笼罩在摄像机前的 Image 控件 游戏进行时，darkImage 处于全透明 不遮挡摄像机绘制的场景画面。 游戏失败时，darkImage 的颜色设置为不透明黑色 屏幕瞬间变黑。 我们使用 Color 类的插值函数 采用线性插值的方法，实现 darkImage 的颜色从不透明黑色 到透明无色的界面效果</p>
</li>
<li><p>敌人排成一排的欢呼效果<br>首先是敌人对象的生成，我们使用 GameObejct 类的 Instantiate 函数实现 其次是敌人面向摄像机，我们使用 Transform 类的 LookAt 函数实现 最后是敌人的欢呼动画：我们使用动画控制器，设置敌人的动画参数 控制敌人欢呼动画的播放</p>
</li>
</ol>
<h4 id="Project3-慕课英雄第一人称完整版总结"><a href="#Project3-慕课英雄第一人称完整版总结" class="headerlink" title="Project3 慕课英雄第一人称完整版总结"></a>Project3 慕课英雄第一人称完整版总结</h4><p>首先我们更改项目的人称视角，把项目设置为第一人称设计游戏 接着我们学习 Unity 中的 UGI 技术 并使用 UGI 技术制作了游戏界面与移动平台的控制界面 然后我们学习 Unity 中的粒子系统与线渲染器 向场景中添加了火炬、 敌人受伤以及枪械开火等视觉效果 最后我们向项目中添加了物品收集功能，同时制作了游戏胜利和游戏失败的画面</p>
<p>（你已经掌握了 Unity 的高级特性 可以使用 Unity 编辑器开发移动端和 PC 端的 Unity 项目）</p>
<h4 id="至此学完本门课程！"><a href="#至此学完本门课程！" class="headerlink" title="至此学完本门课程！"></a>至此学完本门课程！</h4><p>在本门课程中，我们介绍了游戏开发、 游戏引擎和游戏资源等游戏编程的基本概念 并简单的讲解了 C# 基本编程语法。 本门课程 大部分时间用于讲述如何使用 Unity 进行移动平台游戏的开发 本门课程中涉及到 3 个项目的制作 第一个项目，《多米诺骨牌》的开发。 我们使用游戏对象与组件、 物理系统、 图形系统、 音频系统 以及已经编辑好的 Unity 脚本，制作了一个 Unity 场景 在第二个项目《慕课英雄》第三人称简易版的开发过程中 我们讲述如何使用 C# 进行 Unity 脚本编写 实现场景中游戏对象的逻辑与交互。 同时讲解 Unity 中的地形系统与动画系统，完成场景地形的制作 以及角色模型动画的管理 在第三个项目《慕课英雄》第一人称设计版的 开发过程中，我们讲解了游戏人称的变化，Unity 技术中的图形用户界面与移动平台界面 粒子系统与线渲染器，同时完成物品收集功能的实现 以及游戏开始、 结束界面的制作，最后 我们将《慕课英雄》第一人称完整版发布到移动端和 PC 端 相信通过这门课的学习 你已经理解了 Unity 引擎的主要功能，能够自主开发拥有游戏基本元素的 Unity 移动端游戏 你已经在游戏开发的道路上迈出了重要的一步 但是在距离开发以个能进行商业化的 Unity 游戏，仍有很大的差距 这就是我们开设《Unity 游戏编程进阶》课程的原因 在《Unity 游戏编程进阶》课程中，我们在本门课程的基础上，重点讲解 如何进行多人网络手游的开发，同时讲述如何提升游戏的可玩性、 视觉效果，并讲述提升游戏性能的方法 </p>
<h3 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h3><p>今天是6月4日，然我的笔记是在5月4日就做完的。现在才整理上传，拖延症太严重！要继续学习U3d的进阶课程，并且学一下计算机图形学，这就是剩下的大三下要做的事情了。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/06/04/基于Unity引擎的游戏开发基础-课程笔记5/" class="archive-article-date">
  	<time datetime="2017-06-04T02:00:00.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-06-04</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/">Unity</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-基于Unity引擎的游戏开发基础-课程笔记4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/20/基于Unity引擎的游戏开发基础-课程笔记4/">基于Unity引擎的游戏开发基础-课程笔记4</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="动画状态机（Animaation-State-Machine）"><a href="#动画状态机（Animaation-State-Machine）" class="headerlink" title="动画状态机（Animaation State Machine）"></a>动画状态机（Animaation State Machine）</h3><p> Animator 组件：用于控制游戏对象的动画包括建立状态机 调整动画参数以及使用代码控制动画<br>给游戏对象添加 Animator 组件<br> 首先选中游戏对象，再选择 Component 的菜单栏，点击 Mis 菜单项目中的 Animator，即可完成游戏对象 Animator 组件的添加</p>
<h3 id="Animator-组件的常用属性，"><a href="#Animator-组件的常用属性，" class="headerlink" title="Animator 组件的常用属性，"></a>Animator 组件的常用属性，</h3><p> Controller 表示游戏对象的动画控制器的设置 Avatar 表示游戏对象的 Avatar 设置，Apply Root Motion 表示游戏对象的位移或旋转是否由动画片段控制 该属性勾选表示游戏对象的位移和旋转由动画片段控制 该属性不勾选表示游戏对象的位移和旋转由脚本控制<br>通常情况下，一个游戏对象拥有多个动画片段 Animator Controller (动画控制器)，允许开发者管理游戏对象的一系列动画片段</p>
<p>Animation State Machine (动画状态机) 用于管理动画的播放与动画之间的过渡。<br> Animation Layers &amp; Avatar Mask 动画层和身体蒙版用于管理不同身体部位的动画。</p>
<p>在游 戏中，我们使用键盘控制角色的行为，例如 WSAD 控制角色移动，空格键控制角色的跳跃<br> 角色的行为影响动画片段的播放与切换，例如角色在移动时 播放移动动画，在跳跃时播放跳跃动画<br>在 Unity 中，我们使用 Animation State Machine (动画状态机) 控制角色动画片段的播放与切换 </p>
<p>动画状态机的基本思想是 让角色在给定的状态执行特定的动作 状态执行存在过渡，用于改变角色所处的状态 状态过渡需要满足一定的条件：动画状态机使用参数，控制状态之间的过渡</p>
<h3 id="Animation-State-Machine示例"><a href="#Animation-State-Machine示例" class="headerlink" title="Animation State Machine示例"></a>Animation State Machine示例</h3><p>首先导入 Unity 标准资源中的角色和动画资源。<br>在 Project 视图中点击鼠标右键，选择 Import Package 中的 Characters 完成角色和动画资源的导入</p>
<p>取消掉动画过度线中的Has Exit Time 这样过度的更快</p>
<h3 id="Animator-Controller-（动画控制器）"><a href="#Animator-Controller-（动画控制器）" class="headerlink" title="Animator Controller （动画控制器）"></a>Animator Controller （动画控制器）</h3><p>通常情况下 一个游戏对象拥有多个动画片段，Animator Controller（动画控制器）允许开发者管理游戏对象的一系列动画片段</p>
<p>射击类游戏中，我们需要实现”奔跑时射击” “跳跃时射击”、 “行走时射击”等动作 有两种方法可以实现该功能。 第一种方法是分别为这些动作制定 对应的动画，这种方法在动画数量很多的工程项目中带来很大的工作量 另一种方法是将”奔跑”、 “跳跃”等动画与”射击”动画相结合 身体的下半部分使用”奔跑”动画，上半部分使用”射击”动画 这种方法使用了 Unity 中动画层与身体遮罩的技术 Animation Layer 动画层与 Avatar Mask 身体遮罩可以用于合成身体不同部位的动画</p>
<p>Animator Layers&amp;Avatar Mask（动画层和身体遮罩）<br>用于合成身体不同部位的动画</p>
<p>Unity使用Animation Layer（动画层）来管理身体不同部分的动画</p>
<h3 id="动画层的参数设置"><a href="#动画层的参数设置" class="headerlink" title="动画层的参数设置"></a>动画层的参数设置</h3><p>首先是 Weight，表示该动画层对角色整体动画的影响程度 取值范围 0 到 1，动画最底层的位置值，固定为 1<br>其次是 Mask 动画层的身体遮罩设置，表示该动画层影响人形角色的身体关节</p>
<h3 id="Avatar-Mask身体遮罩"><a href="#Avatar-Mask身体遮罩" class="headerlink" title="Avatar Mask身体遮罩"></a>Avatar Mask身体遮罩</h3><p>可以使得开发者选择性的起用或禁用人形角色相关的关节，以控制动画片段对人形角色的影响；启用的关节受动画的控制而产生动作，禁用的关节不受动画的控制</p>
<p>身体遮罩创建步骤<br>在 Project 视图中点击鼠标右键，选择 Create 下面的 Avatar Mask，即可完成身体遮罩的创建<br>以在 Inspector 视图中进行身体遮罩的设置</p>
<p>在 Humanoid 标签中，我们点击人形关节 控制人形关节的启用和禁止</p>
<p>绿色表示启用，红色表示禁用</p>
<h3 id="游戏逻辑-玩家与敌人设置"><a href="#游戏逻辑-玩家与敌人设置" class="headerlink" title="游戏逻辑-玩家与敌人设置"></a>游戏逻辑-玩家与敌人设置</h3><h4 id="玩家运动实现"><a href="#玩家运动实现" class="headerlink" title="玩家运动实现"></a>玩家运动实现</h4><p>在游戏项目 中，我们使用键盘输入来控制玩家的运动， W、 S 键 控制玩家向前、 向后运动，A、 D 键控制玩家的左转、 右转行为<br>空格键控制玩家的跳跃。<br>游戏中摄像机采用第三人称视角 摄像机设定为玩家对象的子对象，摄像机与玩家之间的相对位置和朝向保持不变 跟随玩家一起进行平移、 旋转和跳跃</p>
<h4 id="控制玩家运动的技术要点"><a href="#控制玩家运动的技术要点" class="headerlink" title="控制玩家运动的技术要点"></a>控制玩家运动的技术要点</h4><p>使用 PresentationSetting 的 InputSystem 中默认的参数 获得玩家键盘、 鼠标、 游戏手柄等输入设备的值<br>前后运动<br>使用 Input 类的 GetAxisRaw 函数 并使用参数 “Vertical” 来获取键盘垂直轴方向上的输入 同时根据垂直输入使用 Transform 类的 Translate 函数实现角色的位移<br>左右转向<br>使用 Input 类的 GetAxisRaw 函数 并使用参数 “Horizontal” 来获取玩家键盘水平轴方向上的输入 同时根据水平输入使用 Transform 类的 Rotate 函数实现角色的旋转 </p>
<h4 id="控制玩家跳跃的技术细节"><a href="#控制玩家跳跃的技术细节" class="headerlink" title="控制玩家跳跃的技术细节"></a>控制玩家跳跃的技术细节</h4><p>首先需要检测玩家是否按下跳跃键 这里将空格定义为跳跃键，还需要判断玩家是否在地面上 我们使用 InputDot GetKeyDown 函数对玩家键盘输入进行检测 玩家是否在地面上使用 Physics 类的 Raycast 函数 以玩家位置为起点向下发射一条射线 根据射线与地面的碰撞检测结果来确定玩家是否在地面上 玩家跳跃逻辑实现玩家向上跳跃 播放玩家跳跃的动画。 玩家向上跳跃使用 RigidBody 类的 AddForce 函数 给玩家添加一个向上的瞬时速度来实现跳跃的效果 玩家跳跃动作发生时需要使用 Animator 类的 SetBool 函数 来控制跳跃动画的播放 下面在 PlayerMove 脚本中实现玩家跳跃的代码 我们使用 Physics RayCast 函数从玩家位置向下 发射一条射线，如果射线在很短的距离内与地面发生碰撞 表示玩家在地面上，Jump（isGrounded）参数设备处 接着我们调用 Jump 函数实现玩家跳跃的相关逻辑 在 Jump 函数中，若玩家按下了跳跃键，且玩家处于地面上 执行玩家跳跃逻辑 我们通过给玩家的刚体组件施加一个向上的力 改变玩家的瞬时速度，实现玩家的跳跃行为 我们使用 Animator 类的 SetBool 函数设置布尔类型的动画参数与其 Jump 值 控制玩家跳跃动画的播放</p>
<h3 id="摄像机行为"><a href="#摄像机行为" class="headerlink" title="摄像机行为"></a>摄像机行为</h3><p>三人称设计游戏，我们将摄像机设置为玩家角色的子对象 调整摄像机与玩家之间的相对位置和朝向 使玩家出现在游戏画面的合适区域。 游戏过程中摄像机与玩家之间的相对位置和朝向保持不变 跟随玩家一起进行平移、 旋转和跳跃</p>
<p>按照老师的操作步骤添加了playerMove脚本运行，但是我的角色跑动时没有正常播放跑动动画，第一时间检测了Animator里的参数是-否有错，结果发现自己的isMove参数写成了isMoov导致不能正常播放动画，改正后正确。</p>
<p>playMove脚本：</p>
<pre><code>using UnityEngine;
using System.Collections;

public class PlayerMove : MonoBehaviour {

    public float moveSpeed = 10.0f;        //玩家移动速度
    public float rotateSpeed = 40.0f;    //玩家旋转速度
    public float jumpVelocity = 2.0f;    //玩家起跳速度

    private Animator animator;        //玩家的Animator组件，用于控制玩家动画的播放
    private Rigidbody rigidbody;    //玩家的刚体组件

    private float h;                //获取玩家横轴输入
    private float v;                //获取玩家纵轴输入
    private bool isGrounded;        //玩家是否在地面上
    private float groundedRaycastDistance = 0.1f;    //表示向地面发射射线的射线长度

    //初始化，获取玩家组件
    void Start () {
        animator= GetComponent&lt;Animator&gt; ();    //获取玩家Animator组件
        rigidbody = GetComponent&lt;Rigidbody&gt;();    //获取玩家刚体组件
    }

    //每个固定时间执行一次，用于物理模拟
    void FixedUpdate()
    {
        //从玩家的位置垂直向下发出长度为groundedRaycastDistance的射线，返回值表示玩家是否该射线是否碰撞到物体，该句代码用于检测玩家是否在地面上
        isGrounded = Physics.Raycast(transform.position, -Vector3.up, groundedRaycastDistance);
        Jump(isGrounded);    //调用跳跃函数
    }

    //跳跃函数，用于FixedUpdate()中调用
    void Jump(bool isGround)
    {
        //当玩家按下跳跃键Space，并且玩家在地面上时执行跳跃相关函数
        if (Input.GetKey(KeyCode.Space) &amp;&amp; isGround)
        {
            //给玩家刚体组件添加向上的作用力，以改变玩家的运动速度，改变值为jumpVelocity
            rigidbody.AddForce(Vector3.up * jumpVelocity, ForceMode.VelocityChange);    
            animator.SetBool(&quot;isJump&quot;, true);    //设置动画参数，将isJump布尔型参数设置为true，播放玩家跳跃动画
        }
        else if(isGround) animator.SetBool(&quot;isJump&quot;, false);    //设置动画参数，将isJump布尔型参数设置为false，停止播放玩家跳跃动画
    }

    //每帧执行一次，用于玩家的位移与旋转
    void Update () {
        float h = Input.GetAxisRaw(&quot;Horizontal&quot;);    //获取玩家水平轴上的输入
        float v = Input.GetAxisRaw(&quot;Vertical&quot;);        //获取玩家垂直轴上的输入
        MoveAndRotate(h, v);        //根据玩家在水平、垂直轴上的输入，调用玩家的位移与旋转函数
    }

    //玩家的位移与旋转函数
    void MoveAndRotate(float h, float v)
    {
        //v&gt;0表示获取玩家向前的输入，玩家以moveSpeed的速度向前运动
        if (v &gt; 0) transform.Translate(Vector3.forward * moveSpeed * Time.deltaTime);    
        //v&lt;0表示获取玩家向后的输入，玩家以moveSpeed的速度向后运动
        else if (v &lt; 0) transform.Translate(-Vector3.forward * moveSpeed * Time.deltaTime);    

        //若玩家垂直轴上有输入，则表示玩家进行位移，设置动画参数，将isMove布尔型参数设置为true，播放玩家奔跑动画
        if (v != 0.0f) animator.SetBool(&quot;isMove&quot;, true);
        //若玩家垂直轴上无输入，则表示玩家没有位移，设置动画参数，将isMove布尔型参数设置为false，停止播放玩家奔跑动画
        else animator.SetBool(&quot;isMove&quot;, false);

        //根据玩家水平轴的输入进行旋转，顺时针为正方向
        transform.Rotate(Vector3.up * h * rotateSpeed * Time.deltaTime);
    }

}
</code></pre><p>玩家生命值管理</p>
<p>脚本代码实现如下：</p>
<pre><code>using UnityEngine;
using System.Collections;

public class PlayerHealth : MonoBehaviour {

    public int health = 10;            //玩家的生命值
    public bool isAlive = true;        //玩家是否存活

    //每帧执行一次，检测玩家是否存活
    void Update () {    
        if (health &lt;= 0)
            isAlive = false;
    }

    //玩家扣血函数，用于GameManager脚本中调用
    public void TakeDamage(int damage){
        health -= damage;
        if (health &lt; 0) 
            health = 0;
    }
}
</code></pre><h3 id="玩家攻击实现"><a href="#玩家攻击实现" class="headerlink" title="玩家攻击实现"></a>玩家攻击实现</h3><p>玩家按下键盘的 J 键 游戏画面中玩家抬手向屏幕中央准星内的目标进行攻击<br> 同时枪口发出激光射线，播放射击音效<br>我们限制了玩家的攻击频率，玩家的两次射击动作之间需要一定的时间间隔<br>（屏幕准星的实现涉及图形用户界面）</p>
<p>玩家射击需要满足两个条件<br>按下射击键J（使用Input类的GetKeyDown函数来检测是否按下）<br>2.检查本次设计与上次的攻击间隔，该时间间隔必须大于预定的时间间隔（使用Time类的delta Time来进行时间累加）</p>
<p>满足射击条件后，脚本执行射击逻辑:<br>1.准星射击<br>（Physice类的RayCast函数检测射线是否接触到敌人，执行敌人扣血等相关动作）</p>
<p>2.射击动画<br>Animator类的SetBool函数控制动画的播放<br>3.枪口射线<br>(线渲染器)<br>4.射击音效<br>(AudioSource类的PlayClipAtPoint函数)</p>
<p>PlayerAttack 实现攻击代码</p>
<pre><code>public class PlayerAttack : MonoBehaviour {

    public int shootingDamage = 1;                //玩家射击伤害
    public float shootingRange=50.0f;            //玩家射击范围
    public AudioClip shootingAudio;                //玩家射击音效
    public float timeBetweenShooting = 1.0f;    //射击之间的最小时间间隔（玩家射击动画为1秒，为了使得动画正常播放，该值最好&gt;=1.0f）

    private Animator animator;            //玩家的Animator组件，用于控制玩家动画的播放
    private LineRenderer gunLine;        //玩家的线渲染器组件，用于控制玩家开枪发出的激光射线效果

    private float timer;                //攻击时间间隔，记录玩家从上次射击到现在经过的时间
    private Ray ray;
    private RaycastHit hitInfo;

    //初始化，获取对象组件，以及初始化变量
    void Start () {
        animator = GetComponentInParent&lt;Animator&gt;();    //获取玩家的Animator组件
        gunLine = GetComponent&lt;LineRenderer&gt;();            //获取玩家的线渲染器组件
        timer = 0.0f;        //将攻击时间间隔清零
    }

    //每帧执行一次，用于玩家的射击行为
    void Update () {
        //当玩家按下攻击键J，并且攻击间隔大于射击之间的最小时间间隔，执行射击相关行为
        if (Input.GetKeyDown(KeyCode.J) &amp;&amp; timer&gt;timeBetweenShooting)
        {
            timer = 0.0f;                            //射击后将攻击时间间隔清零
            animator.SetBool(&quot;isShooting&quot;, true);    //设置动画参数，将isShooting布尔型参数设置为true，播放玩家射击动画
            Invoke(&quot;shoot&quot;, 0.5f);                    //0.5秒后调用shoot() 射击函数
        }
        //否则，表示射击条件未满足
        else
        {
            timer += Time.deltaTime;    //更新攻击间隔，增加上一帧所花费的时间
            gunLine.enabled = false;    //将线渲染器设为禁用
            animator.SetBool(&quot;isShooting&quot;, false);    //设置动画参数，将isShooting布尔型参数设置为false，停止播放玩家射击动画
        }
    }

    //射击函数
    void shoot()
    {
        AudioSource.PlayClipAtPoint(shootingAudio, transform.position);    //在枪口位置播放射击音效
        ray.origin = Camera.main.transform.position;    //设置射线发射的原点：摄像机所在的位置
        ray.direction = Camera.main.transform.forward;    //设置射线发射的方向：摄像机的正方向
        gunLine.SetPosition(0, transform.position);        //设置线渲染器（开枪后的激光射线）第一个端点的位置：玩家枪械的枪口位置（本游戏对象）
        //发射射线，射线有效长度为shootingRange，若射线击中任何游戏对象，则返回true，否则返回false
        if (Physics.Raycast(ray, out hitInfo, shootingRange))
        {
            if (hitInfo.collider.gameObject.tag == &quot;Enemy&quot;)    //当被击中的游戏对象标签为Enemy，表明射线射中敌人
            {
                //获取该名敌人的EnemyHealth脚本组件
                EnemyHealth enemyHealth = hitInfo.collider.gameObject.GetComponent&lt;EnemyHealth&gt;();
                if (enemyHealth != null)
                {
                    //调用EnemyHealth脚本的TakeDamage()函数，对敌人造成shootingDamage的伤害
                    enemyHealth.TakeDamage(shootingDamage);    
                }
                if(enemyHealth.health&gt;0)    //若敌人受伤且未死亡，敌人将会因受到攻击而被击退
                    hitInfo.collider.gameObject.transform.position += transform.forward * 2;
            }
            gunLine.SetPosition(1, hitInfo.point);    //当射线击中游戏对象时，将线渲染器（开枪后的激光射线）第二个端点设为射线击中游戏对象的点
        }
        //若射线未射中游戏对象，则将线渲染器（开枪后的激光射线）第二个端点设为射线射出后的极限位置
        else gunLine.SetPosition(1, ray.origin + ray.direction * shootingRange);
        gunLine.enabled = true;    //将线渲染器（开枪后的激光射线）启用，显示玩家开枪后的效果。
    }
}
</code></pre><h3 id="敌人的追逐逻辑："><a href="#敌人的追逐逻辑：" class="headerlink" title="敌人的追逐逻辑："></a>敌人的追逐逻辑：</h3><p>在游戏中，敌人不断调整朝向，面向追踪目标，向追踪目标移动<br>当敌人与目标距离小于一定距离时，停止移动，对目标进行攻击</p>
<p>具体追踪逻辑：<br>Update函数<br>1.追踪判断条件<br>    包括以下四点：1.敌人是否存活 2.敌人追踪目标是否设置3. 游戏是否处于游戏进行状态4. 敌人与目标距离是否大于追踪的最小值<br>            必须满足四个条件才为True</p>
<p>为True：<br>    调整朝向面向追踪目标<br>    向追踪目标移动一定距离<br>为False：<br>    本次Update函数结束</p>
<p>敌人生命值与分数<br>敌人被玩家攻击时，减少生命值<br>敌人受伤时，出现流血效果，并发出受伤的声音<br>若敌人死亡，敌人会倒地并消失，同时玩家得分增加</p>
<h3 id="敌人生命值管理："><a href="#敌人生命值管理：" class="headerlink" title="敌人生命值管理："></a>敌人生命值管理：</h3><p>生命值降低<br>内置字段health值降低<br>敌人受伤音效<br>AudioSource类的PlayClipAtPoint函数</p>
<p>敌人死亡<br>敌人倒地<br>Animator类的SetBool函数<br>玩家得分<br>GameManger类的AddScore函数实现主角得分<br>敌人消失消失<br>GameObject类的Destory函数</p>
<p>代码实现</p>
<pre><code>using UnityEngine;
using System.Collections;

public class EnemyHealth : MonoBehaviour {

    public int health=2;    //敌人的生命值
    public int value=1;        //玩家击杀敌人后所获得的分数
    public AudioClip enemyHurtAudio;    //敌人的受伤音效

    private Animator animator;            //敌人的Animator组件
    private Collider collider;            //敌人的Collider组件
    private Rigidbody rigidbody;        //敌人的rigidbody组件

    //初始化，获取敌人的组件
    void Start(){
        animator = GetComponent&lt;Animator&gt; ();    //获取敌人的Animator组件
        collider = GetComponent&lt;Collider&gt; ();    //获取敌人的Collider组件
        rigidbody = GetComponent&lt;Rigidbody&gt; ();    //获取敌人的Rigidbody组件
    }

    //敌人受伤函数，用于PlayerAttack脚本中调用
    public void TakeDamage(int damage){    
        health -= damage;            //敌人受伤扣血
        if (enemyHurtAudio != null)    //在敌人位置处播放敌人受伤音效
            AudioSource.PlayClipAtPoint (enemyHurtAudio, transform.position);
        if (health &lt;= 0) {            //当敌人生命值小于等于0时，表明敌人已死亡
            if (GameManager.gm != null) {    
                GameManager.gm.AddScore (value);//玩家获得击杀敌人后得分
            }
            animator.applyRootMotion = true;    //设置Animator组件的ApplyRootMotion属性，使敌人的移动与位移受动画的影响
            animator.SetTrigger (&quot;isDead&quot;);        //设置动画参数，设置isDead的Trigger参数，播放敌人死亡动画
            collider.enabled = false;            //禁用敌人的collider组件，使其不会与其他物体发生碰撞
            rigidbody.useGravity = false;        //因为敌人的collider组件被禁用，敌人会因重力穿过地形系统下落，取消敌人受到的重力可以避免该现象
            Destroy (gameObject, 3.0f);            //3秒后删除敌人对象
        }
    }
}
</code></pre><h3 id="敌人攻击实现"><a href="#敌人攻击实现" class="headerlink" title="敌人攻击实现"></a>敌人攻击实现</h3><p>当玩家进入敌人攻击范围，敌人攻击玩家，玩家受到伤害<br>当敌人攻击时抬手，脚本播放敌人攻击音效<br>敌人不会持续攻击，攻击之间有间隔</p>
<p>敌人攻击逻辑：<br>两个条件<br>检测玩家是否处于敌人攻击范围<br>OnTriggerStay函数检测玩家是否处于敌人的攻击范围<br>距离上次敌人攻击经过了一段时间<br>Time类的Delta Time属性累加时</p>
<p>攻击时：<br>抬手击打动画<br>    Animator类的SetBool函数<br>攻击音效播放<br>    AudioSource类的PlayClipAtPoint函数<br>玩家受伤掉血<br>    GameManager类中的PlayTakeDamage函数</p>
<p>在EnemyAttack实现攻击代码<br>    public class EnemyAttack : MonoBehaviour {</p>
<pre><code>    public int damage=1;                    //敌人攻击造成的伤害值
    public float timeBetweenAttack=0.8f;    //敌人攻击之间的最小间隔（敌人攻击动画约为0.8秒，为了使得动画正常播放，该值最好设为0.8秒）
    public AudioClip enemyAttackAudio;        //敌人的攻击音效

    private float timer;                //攻击时间间隔，记录敌人从上次攻击到现在经过的时间
    private Animator animator;            //敌人的Animator组件，用于控制敌人动画的播放
    private EnemyHealth enemyHealth;    //敌人的生命值脚本

    //初始化，获取对象组件，以及变量初始化
    void Start(){
        timer = 0.0f;                                //将攻击时间间隔初始化
        animator = GetComponent&lt;Animator&gt; ();        //获取敌人的Animator组件    
        enemyHealth = GetComponent&lt;EnemyHealth&gt; ();    //获取敌人的生命值脚本
    }

    //与勾选了isTrigger属性的COllider组件共同用于检测：是否有物体进入敌人的攻击范围
    void OnTriggerStay(Collider collider){
        if (enemyHealth.health &lt;= 0)     //若敌人生命值小于等于0，则说明敌人已经死亡，不具备攻击能力
            return;
        //当攻击间隔大于敌人攻击之间的最小间隔，且进入敌人攻击范围的对象标签是玩家时
        if (timer&gt;=timeBetweenAttack &amp;&amp; collider.gameObject.tag == &quot;Player&quot;) {
            //当游戏状态为游戏进行中（Playing）时
            if(GameManager.gm==null || GameManager.gm.gameState==GameManager.GameState.Playing){
                timer=0.0f;            //攻击后将攻击时间间隔清零
                animator.SetBool (&quot;isAttack&quot;, true);    //设置动画参数，将isAttack布尔型参数设置为true，播放敌人攻击动画
                if(enemyAttackAudio!=null)                //在敌人位置处播放敌人的攻击音效
                    AudioSource.PlayClipAtPoint(enemyAttackAudio,transform.position);
                if (GameManager.gm != null)
                    GameManager.gm.PlayerTakeDamage (damage);//通过GameManager游戏管理类实现玩家扣血的效果
            }
        }
    }

    //与勾选了isTrigger属性的COllider组件共同用于检测：是否有物体离开敌人的攻击范围
    void OnTriggerExit(Collider collider){
        //若离开敌人攻击范围的物体标签是玩家时
        if (collider.gameObject.tag == &quot;Player&quot;)
            animator.SetBool (&quot;isAttack&quot;, false);    //设置动画参数，将isAttack布尔型参数设置为false，停止播放敌人攻击动画
    }

    //每帧执行一次，更新攻击间隔
    void Update(){
        timer += Time.deltaTime;    //更新攻击间隔，增加上一帧所花费的时间
    }
}
</code></pre><h3 id="游戏管理器GameManager"><a href="#游戏管理器GameManager" class="headerlink" title="游戏管理器GameManager"></a>游戏管理器GameManager</h3><p>（脚本）<br>管理游戏的状态（游戏进行中/胜利/失败）<br>管理玩家积分<br>管理场景中对象之间的交互<br>显示游戏的状态（玩家生命值与玩家得分）</p>
<p>Unity游戏从场景加载开始 场景加载完成后，游戏从场景加载状态转换到游戏进行状态 在游戏进行状态，游戏不断地检测玩家分数 和玩家生命值。 玩家加分函数AddScore更新玩家的分数 玩家受伤函数PlayerTakeDamage更新玩家生命值 当玩家分数大于等于10，游戏从进行状态转换到游戏胜利状态 如果玩家存活标记isAlive值为false，游戏从进行状态转换到游戏失败状态 在游戏胜利或失败后，都将重新加载场景，开始新一轮的游戏</p>
<h3 id="GameManageer游戏对象创建"><a href="#GameManageer游戏对象创建" class="headerlink" title="GameManageer游戏对象创建"></a>GameManageer游戏对象创建</h3><p>首先我们在 Hierarchy 视图中创建空游戏对象 将其重命名为 GameManager 同时将 Project 视图中 Scripts 文件夹下的 GameManager 脚本拖入到 GameManager 游戏对象上</p>
<p>在检视视图中设置相关参数</p>
<h3 id="敌人的自动生成"><a href="#敌人的自动生成" class="headerlink" title="敌人的自动生成"></a>敌人的自动生成</h3><p>在给定地点动态生成敌人<br>每次生成敌人的时间间隔是随机的</p>
<p>敌人自动生成的逻辑 我们使用两个 Float 变量 T1 和 T2，实现敌人生成的随机性 T1 保存从上次敌人生成结束，到游戏当前帧系统经过的时间 T2 保存下次生成敌人的时间阈值 T2 是某个范围的随机数，敌人生成的随机性由 T2 决定 我们在 Update 函数中，编写敌人随机生成的脚本 首先 T1 对前一帧的执行时间进行累加操作，T1 值不断变大 然后将 T1 与 T2 进行比较，若 T1 小于 T2 表示距离敌人生成的时刻还有一段时间，本次 Update 函数执行结束 若 T1 ≥ T2，开始生成敌人对象 执行以下逻辑，创建敌人的对象，将 T1 设置为 0 随机生成下一次敌人生成的时间阈值，将这阈值赋予 T2 上述逻辑执行完毕，开始下一轮 Update 函数的执行</p>
<h3 id="《慕课英雄》第三人称简易版的制作"><a href="#《慕课英雄》第三人称简易版的制作" class="headerlink" title="《慕课英雄》第三人称简易版的制作"></a>《慕课英雄》第三人称简易版的制作</h3><p>简单回顾一下，整个项目所涉及的知识要点<br>首先，我们学习了 Unity 中的地形系统，完成项目中的地形的构造 其次，我们学习了 Unity 中动画系统，在项目中添加了玩家模型和敌人模型 并完成他们的动画控制。 接着，我们使用 Unity 脚本，实现了项目中玩家的移动、 射击等功能 我们实现了项目中敌人追踪、 攻击等功能 还实现了项目中游戏管理以及敌人自动生成的功能 </p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/04/20/基于Unity引擎的游戏开发基础-课程笔记4/" class="archive-article-date">
  	<time datetime="2017-04-20T10:38:11.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-04-20</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/">Unity</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-基于Unity引擎的游戏开发基础-课程笔记3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/12/基于Unity引擎的游戏开发基础-课程笔记3/">基于Unity引擎的游戏开发基础-课程笔记3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>//今天晚上写了一道bfs 没写出来。太容易沉迷其中不能脱身用大局观看这种东西。费脑子也费时间！！！阿西吧</p>
<p>第二周学习是C#基础。因为我有编程基础且本学期正在学习这门语言，故跳过。但要学习脚本必须要有C#的基础知识！补上了再看脚本！</p>
<h3 id="Unity脚本基本概念"><a href="#Unity脚本基本概念" class="headerlink" title="Unity脚本基本概念"></a>Unity脚本基本概念</h3><p>交互是游戏开发中必不可少的概念，它使玩家能根据自己的意愿改变游戏场景中的某些元素与行为<br>交互包括玩家通过输入系统与游戏场景进行互动，也包括游戏场景中游戏对象之间的交互<br>开发者实现游戏交互功能的主要手段，实现交互的主要工具就是脚本 （Script）</p>
<p>在 Project 视图中 点击鼠标右键，选择 Create 菜单下面的 C# 即可完成脚本的创建 </p>
<p>根据脚本的实际功能 将脚本绑定到场景中与脚本相关的游戏对象 绑定前的脚本作为游戏资源保存在项目目录下，绑定后的脚本成为该游戏对象的组件</p>
<p>Unity 编辑器中创建的脚本 都默认继承了 MonoBehaviour 类，并带有 MonoBehaviour 类中的定义的两个 Unity 事件函数 Start 和 Update</p>
<h3 id="修改-Unity-脚本默认开发工具的流程"><a href="#修改-Unity-脚本默认开发工具的流程" class="headerlink" title="修改 Unity 脚本默认开发工具的流程"></a>修改 Unity 脚本默认开发工具的流程</h3><p> 首先点击 Edit 菜单栏中的 Preferences，打开 Unity Preferences 窗口 接着点击 Unity Preferences 窗口中的外部工具标签 将外部编辑工具改为 Visual Studio 2015<br>在 Unity 脚本中使用 Debug.Log Debug.LogWarning、 Debug.LogError 等函数 在控制台输出我们所需要的脚本调试信息</p>
<h3 id="Console（控制台）视图"><a href="#Console（控制台）视图" class="headerlink" title="Console（控制台）视图"></a>Console（控制台）视图</h3><p>Clear 点击将删除控制台当前所有信息<br>Collapse 按钮起用时。相同的信息在控制台只显示一次（消息尾部显示它出现的次数）<br>Clear On play 在每次游戏预览时，Unity 清除控制台显示的所有消息<br>Error Pause 按钮，在游戏预览过程中，如果脚本出现错误 Unity 中断本次游戏预览</p>
<h3 id="脚本生命周期："><a href="#脚本生命周期：" class="headerlink" title="脚本生命周期："></a>脚本生命周期：</h3><h4 id="初始化阶段："><a href="#初始化阶段：" class="headerlink" title="初始化阶段："></a>初始化阶段：</h4><p>1.Awake() 在脚本绑定到的游戏对象激活时执行 这里需要注意：即使包含 Awake 函数的脚本组已禁用状态 该脚本中的 Awake 函数也会被 Unity 调用<br>2.OnEnable() 当对象变为可用或激活状态时 该函数执行一次<br>3.Start () 第一次Update之前调用；Start 在每个场景中只执行一次，如果在场景中已经执行过 Start 函数 即使 OnEnable 函数再次执行，Start 函数也不会执行</p>
<h4 id="循环阶段"><a href="#循环阶段" class="headerlink" title="循环阶段:"></a>循环阶段:</h4><p>4.FixedUpdate 固定更新<br>物理循环，物理循环用于处理游戏中与物理相关的逻辑 FixedUpdate 函数是物理循环中最先执行的函数 它每隔固定时间执行一次，我们通常与把物理模拟有关的代码 写在 FixedUpdate 函数中</p>
<p>5.OnTrigger 函数，它用于 Trigger 触发器检测 每隔固定时间检测一次。 触发器检测函数包括 OnTriggerEnter，OnTriggerStay，OnTriggerExit 当物体进入，停留，离开 Trigger 触发器范围时执行<br>6.OnCollision 碰撞检测函数 它用于 Collider 碰撞体的相关检测，每隔固定时间检测一次。 碰撞检测函数包括 OnCollisionEnter OnCollisionStay，OnCollisionExit，当物体进入，停- 留，离开 Collider 碰撞体范围时执行 OnTrigger 函数与 OnCollision 函数通常用于与碰撞检测有关的游戏逻辑</p>
<ol>
<li>OnMouse 函数，处理鼠标的输入事件</li>
</ol>
<h4 id="游戏逻辑循环"><a href="#游戏逻辑循环" class="headerlink" title="游戏逻辑循环"></a>游戏逻辑循环</h4><p>7.Update 函数 它在每帧执行一次，该函数主要处理游戏对象在游戏世界的行为逻辑 例如游戏角色的控制和游戏状态的控制<br>8.LateUpdate 函数，它也是每帧执行一次，在 Update 函数后执行。 在实际开发过程中 Update 函数与 LateUpdate 函数通常共同使用，例如在第三人称射击游戏中 我们在 Update 函数中处理玩家角色的移动，在 LateUpdate 函数中处理摄像机跟随玩家 这样能防止摄像机出现抖动现象。</p>
<h4 id="游戏逻辑循环结束后"><a href="#游戏逻辑循环结束后" class="headerlink" title="游戏逻辑循环结束后"></a>游戏逻辑循环结束后</h4><p>9.OnGUI 渲染和处理GUI事件 用到NGUI插件<br>OnGUI 函数每帧可执行多次，用于绘制 Unity 的图形用户界面</p>
<p>在脚本被禁用前，Unity 循环调用物理循环到游戏循环到OnGUI()函数 实现游戏对象的正常更新<br>脚本被禁用时，Unity跳出循环调用</p>
<p>10.OnDisable 当前对象不可用或非激活状态时被调用等待命令。若重新启用脚本 脚本将从 OnDisable 函数跳转至 OnEnable 函数 跳转完成后，脚本按照生命周期中函数执行顺序 循环运行，直到下一次脚本被禁用<br>当脚本 被解除绑定时调用<br>11.OnDestory 被销毁时调用<br>脚本的生命周期结束</p>
<h3 id="Unity脚本之间的执行顺序"><a href="#Unity脚本之间的执行顺序" class="headerlink" title="Unity脚本之间的执行顺序"></a>Unity脚本之间的执行顺序</h3><p>以堆栈的方式，先设置，后执行。也就是说最先绑定的脚本最后执行</p>
<h3 id="使用MonoManager对脚本的执行顺序进行排序："><a href="#使用MonoManager对脚本的执行顺序进行排序：" class="headerlink" title="使用MonoManager对脚本的执行顺序进行排序："></a>使用MonoManager对脚本的执行顺序进行排序：</h3><p>MonoManager的打开方式：<br>打开 Edit 菜单，点击 Project Setting 中的 Script Execution Order，即可打开 MonoManager</p>
<h3 id="使用-MonoManager-管理脚本之间的执行顺序"><a href="#使用-MonoManager-管理脚本之间的执行顺序" class="headerlink" title="使用 MonoManager 管理脚本之间的执行顺序"></a>使用 MonoManager 管理脚本之间的执行顺序</h3><p>首先点击右下方的加号按钮添加 Unity 脚本，其次修改脚本的优先级 该值越小，脚本越早执行。 若把脚本的优先级设置为 0，脚本将在 Default Time 执行 该脚本从列表中消失。 最后点击 Apply 按钮，应用设置。</p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>1.如果脚本没有在 MonoManager 中设置优先级，表明脚本的优先级为 0 脚本在 Default Time 缺省时间执行<br>2.对优先级相等的脚本 采用默认的执行顺序为：最先设置的脚本最后执行<br>3.优先级只表示脚本执行顺序的前后 并不表示脚本执行时间的延迟，例如优先级 = 100，不表示脚本执行延迟 100 毫秒 </p>
<h3 id="在《多米诺骨牌》项目中"><a href="#在《多米诺骨牌》项目中" class="headerlink" title="在《多米诺骨牌》项目中"></a>在《多米诺骨牌》项目中</h3><ol>
<li>实现了大球自转 摄像机围绕金字塔公转</li>
<li>实现大球自转需要两个参数，</li>
<li>自转的旋转轴</li>
<li>每帧的旋转角度 </li>
<li>摄像机围绕金字塔公转需要四个参数 </li>
<li>摄像机公转的旋转中心</li>
<li>公转的旋转轴</li>
<li>每帧旋转角度</li>
<li>摄像机的朝向</li>
</ol>
<p>在脚本中设置为公有字段的可以方便我们在Inspector视图中对该字段进行修改</p>
<p>实现大球自转脚本代码如下</p>
<pre><code>public class SelfRotate : MonoBehaviour {

    public float rotateSpeed = 40.0f;    //旋转速度  可以在Inspector视图中修改
//若脚本中参数的初始值与 Inspector 视图中的设定的值不相等 则以 Inspector 视图中的设定值为准

    //每帧执行一次：物体自转
    void Update () {
        //物体以世界坐标系的向上方向（正Y轴）方向，以rotateSpeed的速度进行顺时针自转
        //Time.deltaTime表示该帧的执行时间，Time.deltaTime * rotateSpeed表示该帧总共自转的角度
        transform.Rotate (Vector3.up, Time.deltaTime * rotateSpeed);    
    }
}
</code></pre><p>transform Rotate 函数实现，该函数需要三个参数 第一个参数是旋转轴向量。 将它设置为 Vector3 的 up 方向，让大球围绕 up 方向，也就是 y 轴进行自转 第二个参数是旋转角度 设置为 Time.deltaTime*rotateSpeed 表示大球在每帧围绕 up 方面的旋转角度 第三个参数是旋转参照系的选择 该参数的缺省值为物体自身的参照系，我们不需要传入这个参数</p>
<p>摄像机围绕金字塔公转脚本：</p>
<pre><code>public class RotateAroundAndLookAt : MonoBehaviour {

    public GameObject rotateCenter;        //旋转中心对象
    public float rotateSpeed = 10.0f;    //旋转速度

    //每帧执行一次：物体公转
    void Update () {
        if (rotateCenter) {        //当旋转中心对象设置时才进行物体公转
            transform.RotateAround (    
                rotateCenter.transform.position,    //旋转中心点
                rotateCenter.transform.up,             //旋转轴：此处设置为为旋转中心的向上方向（正Y轴）
                Time.deltaTime * rotateSpeed        //旋转的角度，rotateSpeed表示旋转的速度，Time.deltaTime表示该帧执行的时间
            );
            transform.LookAt(rotateCenter.transform);    //使游戏对象始终朝向旋转中心
        }
    }
}
</code></pre><p>otate Around 函数 该函数有三个参数，分别是公转的旋转中心 旋转轴向量和旋转角度。<br> 公转的旋转中心坐标设置为 rotateCenter.transform.position 该字段表示旋转中心的位置坐标 旋转轴向量设置为 rotateCenter.transform.up 该字段表示旋转中心的 y 轴正方向 旋转角度设置为 Time.deltaTime*rotateSpeed 该字段表示摄像机在每帧旋转的角度。 最后我们使用 transform 类的 LookAt 函数 以 rotateCenter.transform 作为函数的参数，使摄像机始终朝向旋转中心 最后，把 RotateAroundAndLookAt 脚本 绑定到摄像机游戏对象，并在 Inspector 视图中把参数 rotateCenter 设置为 Hierarchy 视图中的 Top 对象</p>
<p>如何实现骨牌相撞时发出声音？<br>1.如何控制撞击音效的播放时机<br>2.如何播放撞击音效</p>
<p>该脚本代码实现了多米诺骨牌之间相互撞击时播放撞击音效文件</p>
<pre><code>public class DominoCollide : MonoBehaviour {

    //当有物体与该物体即将发生碰撞时，调用OnCollisionEnter()函数
    void OnCollisionEnter(Collision collision)    
    {
        if (collision.gameObject.tag.Equals(&quot;Domino&quot;))    //根据碰撞物体的标签来判断该物体是否为多米诺骨牌
            GetComponent&lt;AudioSource&gt;().Play();            //获取多米诺骨牌撞击音效的AudioSource组件并播放
    }

}
</code></pre><p>如何给大球添加力？<br>如何添加力？<br>如何时刻保持力的作用？</p>
<pre><code>public class ObjectAddForce : MonoBehaviour {

    public int force;    //作用力大小

    //每隔固定时间执行一次，用于物理模拟
    void FixedUpdate () {
        gameObject.GetComponent&lt;Rigidbody&gt;()        //获取游戏对象上的刚体组件
            .AddForce (new Vector3(0,-force,0));    //给刚体添加方向向下的作用力
    }

}
</code></pre><p> ObjectAddForce 类中，字段 force 表示作用力的大小 使用 public 修饰符。 在FixedUpdate 函数内首先获取物体的刚体组件 在调用刚体组件的 AddForce 函数完成作用力的添加 Addforce 函数需要两个参数 第一个参数为力向量，用以表示作用力的大小与方向 第二个参数为力的模式，缺省表示持续作用力</p>
<p>多米诺骨牌中的摄像机切换<br> 如何检测S键是否按下<br> 如何切换摄像机</p>
<pre><code>public class CameraSwitch : MonoBehaviour {

    public Camera mainCamera;    //主摄像机
    public Camera orthCamera;    //正交摄像机

    //摄像机状态初始化
    void Start(){
        mainCamera.enabled = true;    //启用主摄像机
        orthCamera.enabled = false;    //禁用正交摄像机
    }

    //每帧调用一次：摄像机切换
    void Update () {
        if (Input.GetKeyDown(KeyCode.S)){    //当玩家按下键盘上的“S”键时
            mainCamera.enabled = !mainCamera.enabled;    //切换主摄像机的启用与禁用状态
            orthCamera.enabled = !orthCamera.enabled;    //切换正交摄像机的启用与禁用状态
        }
    }
}
</code></pre><h3 id="地形系统（Terrain）"><a href="#地形系统（Terrain）" class="headerlink" title="地形系统（Terrain）"></a>地形系统（Terrain）</h3><p>Unity拥有功能强大且完善的地形编辑器 支持以笔刷的方式，实时绘制多种地形 同时，还提供地表绘制元素，制作树木、 草坪、 石头等地表元素</p>
<h3 id="地形创建的步骤"><a href="#地形创建的步骤" class="headerlink" title="地形创建的步骤"></a>地形创建的步骤</h3><p>在 Hierarchy 视图中，点击鼠标右键 在弹出的菜单中选择 3D Object 中的 Terrain，完成地形创建</p>
<h3 id="地形系统的相关组件"><a href="#地形系统的相关组件" class="headerlink" title="地形系统的相关组件"></a>地形系统的相关组件</h3><p>Transform 组件：<br>更改 Position 属性可以更改地形系统在场景中的位置，而修改 Rotation 与 Scale 属性，并不影响地图系统的朝向与尺寸</p>
<p>Terrain 组件<br>地形编辑工具<br>该组件包含七个按钮，前六个按钮用于实时编辑地形效果 第七个按钮表示该地形系统的属性设置</p>
<p>Terrain Collider 组件<br>该组件表示地形的碰撞体，在创建地形体统 时，会在 Project 视图中自动生成一个地形系统碰撞体 并自动应用到 Terrain Data 属性中 地形系统碰撞体的形状，会根据地形的实时编辑发生改变 </p>
<h3 id="地形系统编辑工具"><a href="#地形系统编辑工具" class="headerlink" title="地形系统编辑工具"></a>地形系统编辑工具</h3><p>Raise/Lower Terrain（升高/降低地形）<br>启用该 按钮，按住鼠标左键拖动，可以升高地形高度，绘制出山脉 按住 shift 键，并按住鼠标左键拖动，可以降低地形高度 绘制出峡谷。 地形高度为 0 时，不再降低<br>相关参数：<br> Brushes，表示绘制地形高度的笔刷样式 Brush Size，表示笔刷尺寸，取值范围为 1 到 100 Opacity 表示绘制强度 用于确定每次点击后地形升高或降低的强度 取值范围为 0 到 100 </p>
<p>Paint Height（喷涂高度）<br>用于将地形绘制到指定高度<br>启用该按钮，按住鼠标 左键拖动，可以改变地形高度，直到地形高度达到指定值<br>相关参数：<br>Height 表示地形指定的高度 点击 Flatten 按钮，可以将整个地形绘制到指定的高度</p>
<p>Smooth Height （平滑高度）<br>点击 Terrain 组件的第三个按钮，打开平滑高度工具 首先可以选择笔刷的样式，并设定大小和强度 然后在地形上拖动鼠标左键，即可提高地形的平滑度 </p>
<p>Paint Texture （绘制纹理）<br>用于绘制地表的纹理<br>启用该按钮，每次点击鼠标左键 进行该区域的纹理绘制。 我们可以点击 Edit Texture 进行纹理设置 第一次添加的纹理会自动应用到整个地形系统 后续添加的纹理将通过笔刷的形式实现绘制</p>
<h3 id="相关参数："><a href="#相关参数：" class="headerlink" title="相关参数："></a>相关参数：</h3><p>Target Strength 表示纹理绘制的最大影响程度 数值 0 表示纹理绘制完全没有影响 数字 1 表示纹理绘制将完全覆盖之前的纹理图像</p>
<p>Place Tree（种植树）<br>用于在地形上添加树模型 在种植树之前需要添加树的模型</p>
<h3 id="树模型的设置步骤："><a href="#树模型的设置步骤：" class="headerlink" title="树模型的设置步骤："></a>树模型的设置步骤：</h3><p>点击 Add Tree 按钮，即可以执行树模型的添加、 编辑 移除操作，选中树模型，选 Mass Place Trees 按钮 可以在整个地形系统中随机种植树木<br>随机种植树的几个相关的参数<br>Number Of Trees，表示随机种植树的个数<br>Keep Existing Trees 选项表示的是是否保留以种植的树<br>设置完成后，点击 Place 按钮 可以在整个地形系统上完成树的随机种植<br>该工具的相关参数<br>Tree Density 表示树绘制的密度，<br>Tree Height，表示绘制的树高度 可以选择随机的范围。<br>Lock Width to Height，确定树的宽高比是否一致<br> Tree Width，表示绘制的树宽度 可以选择随机范围，<br>当 Lock Width to Height 属性不勾选时，可以编辑该属性<br>Random Tree Rotate，用于确定树的朝向是否随机</p>
<p>Paint Detail（绘制细节）<br> 用于在地形上添加草等 在绘制细节之前，需要设置细节的纹理或网格</p>
<h3 id="细节的设置步骤"><a href="#细节的设置步骤" class="headerlink" title="细节的设置步骤"></a>细节的设置步骤</h3><p>点击 Add Detail，开始细节的编辑，分为 Grass Texture 和 Detail Mesh 两种 Grass Texture 用于草纹理的设置，Detail Mesh 用于细节网格的设置</p>
<p>Terrain Setting （地形设置）<br>用于设置地形系统的相关参数<br>Base Terrain，表示地形系统的基本参数设置<br>其中 Draw 表示是否呈现地形系统<br> Pixel Error 表示像素容差，显示地形网格时允许的像素误差<br> Base Map Dist，用于设置高分辨率地形贴图的显示范围。为了提高效率，与摄像机距离超过该值的纹理，将以较低的分辨率显示<br>Cast Shadows，表示该地形是否投射阴影<br>Tree &amp; Detail Objects 表示树和细节的相关参数的设置，其中 Draw 表示是否呈现树 和细节，<br>Detail Distance 用于设置超过摄像机多少距离的细节 将会停止渲染，<br>Tree Distance 表示树的显示距离 树与摄像机距离超过 Tree Distance，不对树进行渲染<br> Resolution，表示地形系统的分辨率设置 其中 Terrain Width 表示地形系统的宽度，Terrain Length 表示地形系统的长度，Terrain Height，表示地形系统的高度</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/04/12/基于Unity引擎的游戏开发基础-课程笔记3/" class="archive-article-date">
  	<time datetime="2017-04-12T14:47:50.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-04-12</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/">Unity</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-基于Unity引擎的游戏开发基础-课程笔记2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/12/基于Unity引擎的游戏开发基础-课程笔记2/">基于Unity引擎的游戏开发基础-课程笔记2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="图形资源分类"><a href="#图形资源分类" class="headerlink" title="图形资源分类"></a>图形资源分类</h4><p>简单地可以分为2D和3D</p>
<p>图形 2D 图形是平面图形，只有长宽两个维度。 三维图形是立体图形 拥有长宽高三个维度。</p>
<p>2D 图形在计算机中有两种表示形式：位图与矢量 位图图像通常称为点阵图像 它是由多个单点的像素组成的，每个像素具有 RGBA 颜色值 所有像素按照矩形进行排列，构成一幅图像 我们用 扫描仪、 手机、 照相机，拍摄获得的照片都是位图</p>
<p>矢量图 矢量图也称为面向对象的图像，或者叫绘图图像 在数学上面可以定义为一系列的点，点之间以线作为连接 矢量文件中的图形元素称为对象 每个对象都是一个自成一体的实体 具有颜色、 形状、 轮廓、 大小和屏幕位置等属性<br>与位图不同，矢量图在放大过程中不会失真 不会出现颗粒感。 矢量图的显示效果与分辨率无关</p>
<h4 id="游戏对象-（GameObject）"><a href="#游戏对象-（GameObject）" class="headerlink" title="游戏对象 （GameObject）"></a>游戏对象 （GameObject）</h4><p>游戏场景中存在的物体都可以称为游戏对象。游戏对象是一个非常广泛的概念，场景中的物体环境元素 特效都是一个游戏对象</p>
<h4 id="标签-tag"><a href="#标签-tag" class="headerlink" title="标签(tag)"></a>标签(tag)</h4><p>游戏对象标签可以方便我们区分一些特殊种类的游戏对象</p>
<h4 id="组件-Component"><a href="#组件-Component" class="headerlink" title="组件(Component)"></a>组件(Component)</h4><p> 在游戏场景中，游戏对象之间的表现与行为差异。Unity使用组件来表示游戏对象的某种属性或行为</p>
<h4 id="Transform组件"><a href="#Transform组件" class="headerlink" title="Transform组件"></a>Transform组件</h4><p>用于设置游戏对象在场景中的位置 朝向以及尺寸<br>绝大部分游戏对象（UI游戏对象除外）都包含Transform组件<br>Transformz组件无法手动添加或删除，创建游戏对象时自带的组件</p>
<ul>
<li>Position：游戏对象相对于其父对象的坐标位置</li>
<li>Rotation：游戏对象相对于其父对象的x y z轴的旋转角度（顺时针为正）</li>
<li>Scale 游戏对象相对于其父对象的x y z轴方向的缩放倍数 1表示原始长度</li>
</ul>
<p>父子关系与Transform组件 当游戏对象称为另一个游戏对象的子对象，该游戏对象的Transform组件会发生改变</p>
<h4 id="预制件（prefab）"><a href="#预制件（prefab）" class="headerlink" title="预制件（prefab）"></a>预制件（prefab）</h4><p>预制件（prefab）是一种资源类型 存储在Project（项目）视图中的游戏对象原型。预制件可以多次放入到多个场景中。当你拖拽一个预制件到场景中，就在该场景中创建了该预制件的一个实例。所有的预制件实例连接到原始预制件。当你对预制件进行任何更改·这些改动都会自动应用于所有预制件实例</p>
<h4 id="物理系统基础"><a href="#物理系统基础" class="headerlink" title="物理系统基础"></a>物理系统基础</h4><p>物理系统 ：在虚拟世界中使用物理引擎，运用物理算法对游戏对象的运动进行模拟，例如重力 摩擦力 碰撞等 ，让游戏更加真实</p>
<h4 id="物理系统组件"><a href="#物理系统组件" class="headerlink" title="物理系统组件"></a>物理系统组件</h4><ul>
<li>刚体（Rigidbody）</li>
<li>恒定力（Constant Force）</li>
<li>碰撞体（Collider）</li>
</ul>
<h4 id="物理系统管理器（Physics-Manager）"><a href="#物理系统管理器（Physics-Manager）" class="headerlink" title="物理系统管理器（Physics Manager）"></a>物理系统管理器（Physics Manager）</h4><ul>
<li><p>刚体（Rigidbody）是物理学中一个重要的概念，它是指一个物体在受力的情况下 其外形 尺寸 内部结构组织等都不受影响的一个特性<br>在Unity中，刚体用于模拟世界中物体受力之后的行为.每个游戏对象只能添加一个刚体组件。</p>
</li>
<li><p>Mass表示对象的质量</p>
</li>
<li>Drag对象运动时的阻力 </li>
<li>Angular Drag对象旋转时的角阻力</li>
<li>Use Gravity：是否应用重力（默认勾选应用重力）</li>
<li>Constraints 表示刚体约束</li>
<li>freeze position 表示位置约束 选择x项表示刚体受力后沿X轴不发生位移</li>
<li>Freeze Rotation 表示旋转约束 勾选x项 表示刚体受力后绕x轴不发生旋转</li>
</ul>
<h4 id="碰撞体（Collider）"><a href="#碰撞体（Collider）" class="headerlink" title="碰撞体（Collider）"></a>碰撞体（Collider）</h4><p>碰撞体定义了对象在物理系统中的碰撞形状，对象的碰撞形状用于物理模拟中的碰撞检测。当两个物体都有碰撞体组件时，物理引擎才会计算碰撞，否则物体会相互穿过。Unity中的内置对象 （Cube，Sphere）都默认添加了缺省形状的碰撞体组件，若无特殊要求我们不需要为其添加新的碰撞体组件</p>
<p>碰撞体的常用属性<br>（以球型碰撞体举例）</p>
<ul>
<li>Edit Collider ：碰撞体形状编辑按钮，点击后可在Scene（场景）视图中编辑碰撞体的形状</li>
<li>is Trigger：该碰撞体是否为触发器（默认不勾选，不是触发器）用于检测是否有物体进入该触发器的区域。碰撞体变成触发器以后，不再具有碰撞体的功能 </li>
<li>Material：碰撞体的物理材质（设置游戏对象受力后的相应）</li>
</ul>
<p>碰撞体形状尺寸设置：</p>
<ul>
<li>Center：球型碰撞体的球心位置</li>
<li>Radius：球型碰撞体的半径</li>
</ul>
<p>碰撞体勾选</p>
<ul>
<li>Is Trigger属性后会变成触发器<br>*一个物体可以拥有多个碰撞体</li>
</ul>
<h4 id="物理材质（Physic-Material）："><a href="#物理材质（Physic-Material）：" class="headerlink" title="物理材质（Physic Material）："></a>物理材质（Physic Material）：</h4><ul>
<li>Dynamic Friction：动摩擦力</li>
<li>Static Friction：静摩擦力</li>
<li>Bounciness:弹力<br>*Friction/Bounce Combine:定义两个碰撞体之间的摩擦力/弹力如何相互作用</li>
</ul>
<h4 id="物理系统管理器-（PhysicsManager）"><a href="#物理系统管理器-（PhysicsManager）" class="headerlink" title="物理系统管理器 （PhysicsManager）"></a>物理系统管理器 （PhysicsManager）</h4><ul>
<li>Gravity：设置物理系统中的重力</li>
<li>Default Material：碰撞体组件默认使用的物理材质</li>
<li>Bounce Threshold：弹性阈值</li>
<li>Default Contact Offset ：两个对象发生碰撞的距离，即当两个对象的距离小于该距离时才会发生碰撞</li>
</ul>
<h4 id="网格（Mesh）"><a href="#网格（Mesh）" class="headerlink" title="网格（Mesh）"></a>网格（Mesh）</h4><p>游戏中三维物体使用网格来描述自身的形状和尺寸。一个模型由若干网格面组成，每一个面由若干个三角形组成</p>
<p>在计算机图形学中 经常使用三角形网格来描述物体的几何信息，可以采用图形卡GPU对三角形网格有关的计算进行加速</p>
<h4 id="网格过滤器（Mesh-Filter）"><a href="#网格过滤器（Mesh-Filter）" class="headerlink" title="网格过滤器（Mesh Filter）"></a>网格过滤器（Mesh Filter）</h4><p>网格过滤器（Mesh Filter）存放游戏对象的网格信息，并把网格信息传递到网络渲染器中，最后将网格渲染到屏幕中。此组件的目的主要用于确定模型的形状与尺寸<br>网络渲染器（Mesh Renderer）</p>
<h4 id="网络渲染器（Mesh-Renderer）"><a href="#网络渲染器（Mesh-Renderer）" class="headerlink" title="网络渲染器（Mesh Renderer）"></a>网络渲染器（Mesh Renderer）</h4><p>从网格过滤器中获取几何形状，用于渲染场景中的模型</p>
<p>网格过滤器与网格过滤器必须成对使用，缺少任意一个都会导致游戏对象的渲染失败。我们可以将网格过滤器看做一个人的骨骼，把网格渲染器看做一个人的血肉。前者决定了游戏对象的几何形状，后者决定了游戏对象的外貌，颜色等表面特质</p>
<h4 id="材质Material"><a href="#材质Material" class="headerlink" title="材质Material"></a>材质Material</h4><p>网格只绘制物体的形状与尺寸，物体表面的颜色，质感特性则需要用材质Material来呈现，材质在物体的网格渲染器中设置。我们可以创建自己的材质<br>材质编辑包括 着色器（Shader）的选择 着色器的相关属性设置 Inspector视图下方有材质预览</p>
<h4 id="着色器（Shader）"><a href="#着色器（Shader）" class="headerlink" title="着色器（Shader）"></a>着色器（Shader）</h4><p>着色器主要用于图像的渲染过程，它具有可编辑性，不受显卡的固定渲染管线限制，可以实现丰富的图像效果。这极大的提高了图像的品质<br>我们可以使用着色器语言来编写相应的着色器脚本，以实现图像渲染的不同效果</p>
<h4 id="标准着色器（Standard-Shader）"><a href="#标准着色器（Standard-Shader）" class="headerlink" title="标准着色器（Standard Shader）"></a>标准着色器（Standard Shader）</h4><p>对于大多数表面效果的渲染（包括人物，风景，环境等），Unity内置的标准着色器（Standard Shader）通常是最好的选择。标准着色器是一个高度可定制的着色器，它能够呈现多种类型的表面效果<br>参数设定：</p>
<ul>
<li>REndering Mode 预设值</li>
<li>Opaque ，不透明</li>
<li>Transparent 透明效果</li>
<li>Fade 淡入淡出的效果</li>
<li><p>cutout 透明与不透明效果</p>
</li>
<li><p>Albedo：表示光的反照率 描述物体的基本颜色</p>
</li>
<li>NormalMap：法向贴图，可以通过改变光的反射角度，使物体显得凹凸不平</li>
<li>Emission：自发光 使得物体看起来“自发光”</li>
</ul>
<h4 id="天空盒（Skybox）"><a href="#天空盒（Skybox）" class="headerlink" title="天空盒（Skybox）"></a>天空盒（Skybox）</h4><p>除了标准着色器外，天空盒也是一种常用的着色器类型。它用于设置场景中的天空背景图案<br>Skybox/6 sided：一种常用的天空盒类型，其通常由x+ x- y+ y- z+ z-六个方向的贴图构成</p>
<h4 id="光源（Light）"><a href="#光源（Light）" class="headerlink" title="光源（Light）"></a>光源（Light）</h4><p>光源是场景的重要组成部分，它决定了场景的明暗，色彩和氛围<br>Light组件 ：type 光源类型 Color：光源颜色 Intensity 光照强度 Bounce Intensity ：反射光强度</p>
<h4 id="光源类型-用途"><a href="#光源类型-用途" class="headerlink" title="光源类型 用途"></a>光源类型 用途</h4><ul>
<li>方向光（Directional）：模拟极远处的光照，如地球上的太阳光</li>
<li>点光源（Point）：模拟光源向四周发出均匀的光线，例如生活中的灯泡</li>
<li>聚光灯（Spot）：模拟光源向某方向发出圆锥体光线，例如手电筒 路灯</li>
<li>面光源（Area）：无法模拟实时光照，用于光照烘焙 </li>
</ul>
<h4 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h4><p>除了光源对象外，场景中还存在环境光，环境光奠定了一个场景的基本色调。环境光的效果在Lighting视图中设置</p>
<h4 id="环境光来源："><a href="#环境光来源：" class="headerlink" title="环境光来源："></a>环境光来源：</h4><ul>
<li>天空盒（Skybox） 若Skybox材质设置，使用该材质所产生的光效果；若Skybox没有选定材质，效果同单色光（Color）</li>
<li>梯度光（Gradient） 拥有Sky，Equator，Ground三个颜色参数，分别对应天空 赤道 地面的光颜色，两两之间光颜色呈梯度分布</li>
<li>单色光（Color）根据选定的颜色作为环境光颜色</li>
</ul>
<h4 id="摄像机（Camera）"><a href="#摄像机（Camera）" class="headerlink" title="摄像机（Camera）"></a>摄像机（Camera）</h4><p>在Unity场景中，必须有一个摄像机用于绘制场景。引擎对摄像机可以看到的游戏世界中的空间区域进行渲染，生成最终的游戏画面。</p>
<p>场景中可以存在多个摄像机：<br>单人模式中只有一个摄像机 多人游戏中有两个摄像机同时渲染画面</p>
<h4 id="摄像机组件"><a href="#摄像机组件" class="headerlink" title="摄像机组件"></a>摄像机组件</h4><ul>
<li>Insector（检视）视图中的摄像机组件 Clear Flags：摄像机清除标记</li>
<li>projection：摄像机投射方式</li>
<li>Field of view：摄像机视角</li>
<li>Clipping Planes：摄像机远近剪切平面</li>
<li><p>Depth：摄像机深度值</p>
<p>清除标记用于填充屏幕中摄像机未绘制的部分（四个可选类）：</p>
</li>
<li><p>Skybox （预设） 以天空盒作为摄像机的清除标记</p>
</li>
<li>Solid Color 以某种颜色作为摄像机的 清除标记</li>
<li>Depth Only 以深度值较低的摄像机渲染的图案作为该摄像机的清除标记（用于多个摄像机的同时绘制）</li>
<li>Dont Clear 不清除，摄像机的清楚标记为上次渲染过的图像</li>
</ul>
<p>Projection（摄像机投影方式）</p>
<ul>
<li>Perspective 透视，在该模式下，摄像机显示的场景画面为我们日常生活中所看到的远小近大现象</li>
<li>Orthograhic 正交，在该模式下，场景中的物体大小不会因为与摄像机的距离不同而发生大小变化 </li>
</ul>
<p>摄像机其他组件</p>
<p><em>　GUI Layer：GUI（Unity4.6之前的旧版）显示组件，使摄像机中能够显示旧版GUI控件
</em>　Flare Layer：镜头耀斑显示组件，使镜头耀斑特效显示在摄像机所渲染的图形中<br>*　Audio Listener：音频监听组件，用于收集游戏场景中的声音并播放 </p>
<h4 id="音频（Audio）"><a href="#音频（Audio）" class="headerlink" title="音频（Audio）"></a>音频（Audio）</h4><p>音频在游戏中的地位至关重要，它给游戏添加视觉效果。优质恰当的音频使得场景更加生动</p>
<p>Unity中的音频系统通过Audio Source，音频源组件和Audio Listener音频监听组件实现</p>
<p>音频源组件用于场景中声音的播放<br>AudioListener，音频监听组件收集场景中发出的声音并播放</p>
<p>如果场景中存在多个音频监听组件，Unity编辑器会随机选择其中的一个音频监听组件生效 其余的音频监听组件均保持静默<br>Unity摄像机对象默认添加了AudioListener组件，<br>inspector视图中音频源组件</p>
<ul>
<li>AudioClip<br>表示音频片段，是音频源组件播放的音频资源 Mute保持音频源播放时是否静音，默认不勾选，表示不静音 Play On Awake表示是否在该音频源组件启动时，自动播放音频片段 默认勾选，表示自动播放；Loop，表示音频源是否循环播放音频片段<br>默认不勾选，表示不循环。 Volume 表示音频片段播放时声音的大小；Pitch，表示音频片段播放时音调的高低 </li>
</ul>
<p>音频系统管理器，AudioManager<br>音频系统管理器管理整个项目中音频系统的相关参数</p>
<p>Edit菜单栏 点击Project<br>Settings中的Audio选项，即可在inspector视图中显示项目的音频系- 统管理器<br>部分参数，Global Volume表示项目的全局音量大小 Disable Unity<br>Audio表示是否使用Unity的音频系统，默认不勾选，即使用Unity的音频系统</p>
<h4 id="项目构建（Build）"><a href="#项目构建（Build）" class="headerlink" title="项目构建（Build）"></a>项目构建（Build）</h4><p>当Unity项目制作完毕，需要对Unity项目进行构建，才能使项目脱离Unity编辑器独立运行。<br>项目构建：File菜单栏-》Build Setting<br>项目构建参数：</p>
<ol>
<li>把场景添加到构建列表<br> 打开需要构建的场景<br> 点击Add Current按钮</li>
<li>选择项目发布的平台<br> 名字后面带有Unity图标的平台表示当前项目所在的平台<br>ps：切换平台：<br>选中项目发布的平台 点击Switch Platform按钮，即可完成项目平台的切换工作</li>
<li>设置平台参数</li>
</ol>
<p>点击player Setting即可设置参数：</p>
<ol>
<li>分辨率与演示设置</li>
<li>项目图标设置</li>
<li>项目启动图像设置</li>
<li>其他设置</li>
<li>生成游戏项目</li>
<li>点击Build即可生成</li>
</ol>
<p>在进行Android平台的项目构建时，需：</p>
<p>1.Android SDK与JDK的下载设置<br>在完成SDK与JDK的下载后 需要在Unity编辑器中，Unity Preference(Edit-&gt;Preference)点击<br>Extends Tools把JDK与SDK目录设置即可<br>2.Android项目参数设置<br>player Setting 中进行 Default Orientation 设置屏幕默认朝向</p>
<p>Status Bar Hidden选项用于隐藏Android 手机的状态栏</p>
<p>Other Sittings需要设置 Identification中的Bundle Identifier该属性表示Android应用的标识符，用于区别该Android应用与其他Android应用 默认为com.Company.ProductName</p>
<p>《多米诺骨牌》项目总结</p>
<p>1.　Unity编辑器基础操作<br>    包括项目的创建，资源的导入，以及游戏对象的创建<br>2.　物理操作系统基础<br>    模拟真实世界的重力 碰撞效果<br>3.　图形系统基础<br>    给场景添加视觉效果<br>4.　音频基础<br>    给场景添加声音效果<br>5.　项目部署<br>    部署到Windows平台与安卓平台独立于Unity编辑器独立运行</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/04/12/基于Unity引擎的游戏开发基础-课程笔记2/" class="archive-article-date">
  	<time datetime="2017-04-12T03:55:09.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-04-12</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/">Unity</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-基于Unity引擎的游戏开发基础-课程笔记1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/10/基于Unity引擎的游戏开发基础-课程笔记1/">基于Unity引擎的游戏开发基础-课程笔记1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="初始"><a href="#初始" class="headerlink" title="初始"></a>初始</h3><pre><code>开始学习Unity时，在知乎上查看了Unity话题内的内容，于是准备先找课去上。本来第一个准备在Coursera上看的无奈寝室的网连视频加载不出来，退而求其次在慕课网上去找。听的基础课程真的是乱的一匹。怒开一波vpn上Coursera的课。讲真，课程讲的超级细致，非常适合初学者。非常感谢复旦大学的老师和学长们录制的这门基础课！
</code></pre><p>//本文档为Coursera 基于Unity引擎的游戏开发基础个人笔记.</p>
<h3 id="游戏引擎功能模块："><a href="#游戏引擎功能模块：" class="headerlink" title="游戏引擎功能模块："></a>游戏引擎功能模块：</h3><ul>
<li>游戏中实时光影绘制</li>
<li>动画系统 </li>
<li>物理模拟系统</li>
<li>游戏场景渲染机制</li>
<li>网络通信 AI系统</li>
<li>平台移植功能</li>
</ul>
<h3 id="Unity编辑器界面介绍："><a href="#Unity编辑器界面介绍：" class="headerlink" title="Unity编辑器界面介绍："></a>Unity编辑器界面介绍：</h3><ol>
<li><p>Project（项目）视图</p>
<p> Project视图是整个项目的资源汇总，包含了游戏项目中的场景 模型 材质 脚本 外部导入的网络模型等所有资源文件</p>
</li>
<li><p>Hierarchy（层级）视图</p>
<p> ierarchy（层级）视图包含了当前场景中所有的游戏对象</p>
</li>
<li><p>Inspector（检视）视图</p>
<p> Inspector（检视）视图用于显示当前选定的游戏对象的详细信息，包括游戏对象的名称，标签，几何属性以及其他组件信息，也可用于显示Edit菜单栏中与项目相关的参数设置</p>
</li>
<li><p>Scene（场景）视图<br> Scene（场景）视图用于显示场景中所有模型，光源，摄像机，材质，音效等游戏对象。在场景视图中，可以通过可视化的方式对场景中的游戏对象进行编辑</p>
</li>
</ol>
<h3 id="Unity编辑器菜单栏："><a href="#Unity编辑器菜单栏：" class="headerlink" title="Unity编辑器菜单栏："></a>Unity编辑器菜单栏：</h3><ul>
<li>File（文件）菜单 主要包含项目与场景的创建 保存及输出等功能</li>
<li>Edit（编辑）菜单 主要包括对场景进行一系列的编辑及环境设置操作等命令</li>
<li><p>Asset（资源）菜单 主要用于对项目视图中的资源进行管理  在Project视图中点击右键打开相似的Asset菜单</p>
</li>
<li><p>GameObject（游戏对象）菜单 对层级视图中的游戏对象进行管理</p>
</li>
<li>Component(组件)菜单 管理选中游戏对象的组件</li>
<li>Window（窗口）菜单 包含各种窗口的切换 布局等操作 还可以通过它打开各种视图以及访问Asset Store资源商店</li>
<li>Help（帮助）菜单 包含Unitu用户手册与脚本参考菜单项，能够帮助开发者学习和掌握Unity</li>
</ul>
<h3 id="Transform-Tools（变化工具）"><a href="#Transform-Tools（变化工具）" class="headerlink" title="Transform Tools（变化工具）"></a>Transform Tools（变化工具）</h3><p>（菜单栏下面的五个按钮）</p>
<ul>
<li>手型工具：用于整体平移Scene视图</li>
<li>移动工具：对选中的对象进行平移操作</li>
<li>旋转工具：对选中的对象进行旋转操作</li>
<li>缩放工具：对选中的对象进行缩放操作</li>
<li>二维缩放工具：对二维物体和uGUI进行缩放</li>
</ul>
<h3 id="Transform-Gizmo-Tools（辅助变换工具）"><a href="#Transform-Gizmo-Tools（辅助变换工具）" class="headerlink" title="Transform Gizmo Tools（辅助变换工具）"></a>Transform Gizmo Tools（辅助变换工具）</h3><p>（Center-Global）</p>
<p>游戏对象的轴心点设置：</p>
<pre><code>Center:以所有选中游戏对象的中心为轴心点；
Pivot：以最后一个选中游戏对象的中心为轴心点（ps：枢轴; 中心点，中枢; [物] 支点，支枢;）
</code></pre><p>游戏对象坐标的显示方式</p>
<pre><code>Global：以全局坐标显示游戏对象坐标；
Local：以自身坐标显示游戏对象坐标
</code></pre><h3 id="Play（播放控制）"><a href="#Play（播放控制）" class="headerlink" title="Play（播放控制）"></a>Play（播放控制）</h3><p> 播放/暂停/逐帧播放<br>运行游戏按钮：控制游戏的运行与结束，Game视图实时地显示游戏的运行效果<br>暂停游戏按钮：暂停/继续游戏 控制游戏的暂停与继续运行；<br>逐帧播放按钮：逐帧播放游戏，主要用于开发者逐帧调试游戏项目</p>
<h3 id="Layers（分层下拉列表）"><a href="#Layers（分层下拉列表）" class="headerlink" title="Layers（分层下拉列表）"></a>Layers（分层下拉列表）</h3><p>Layers（分层下拉列表）用于控制Scene视图中游戏对象的显示，睁眼符号表示属于该层的游戏对象在场景中可见，闭眼表示不可见</p>
<h3 id="Layout（布局下拉列表）"><a href="#Layout（布局下拉列表）" class="headerlink" title="Layout（布局下拉列表）"></a>Layout（布局下拉列表）</h3><p>Layout（布局下拉列表）控制Unity编辑器包含的多个视图布局方式，支持用户自定义布局</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/04/10/基于Unity引擎的游戏开发基础-课程笔记1/" class="archive-article-date">
  	<time datetime="2017-04-10T14:24:16.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-04-10</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/">Unity</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-博弈论最后一章摘录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/09/博弈论最后一章摘录/">博弈论最后一章摘录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>拖了很久，终于要记录下自己觉得迄今为止学到的比较好的的处事规则，一报还一报。</p>
<p>“一报还一报”的4大特点</p>
<ol>
<li>它是善良的（不树敌）</li>
<li>它是可激怒的（防背叛）</li>
<li>它是宽容的（给机会）</li>
<li>它是清晰的（易辨识） </li>
</ol>
<p>“针锋相对”的善良性防止他陷入非合作的麻烦中，对对方背叛的报复则保证了对方背叛行为的谨慎性，宽容性则有助于在对方背叛后重新开始合作，而简单清晰的规则则易于被人理解，从而导出长期的合作。</p>
<p>由此老师给的四点忠告：</p>
<ol>
<li>不要嫉妒</li>
<li>不要首先背叛</li>
<li>对合作和背叛都要给于回报（as soon as possible）</li>
<li>不要耍小聪明 </li>
</ol>
<p>和两点启示：</p>
<ol>
<li>合作的基础不是信任，而是关系的持续性。</li>
<li>组织相对于个人而言往往具有更长的预期寿命，<br>从而提高了关系的持续性。</li>
</ol>
<p>希望我持着这把钝剑勇敢地前行，虽然此生可能不会有大富大贵，但要从长远的目光来看，我只是后人前行的跳板，所以，踏实前行即可。</p>
<p>还记得老师在博弈论第一节课提到的：</p>
<p>知人者智，自知者明</p>
<p>胜人者力，自胜者强</p>
<p>小胜者术，大胜者强</p>
<p>留着回味。</p>
<p>博弈，必须学会换位思考，只需领人一步，高人一筹，两筹多了。<br>博弈。博：博览全局；弈：对弈棋局。讲究 谋定而动 ！ 博弈亦可以是竞争，也可以是合作。<br>博弈的最高境界也即是合作！</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/03/09/博弈论最后一章摘录/" class="archive-article-date">
  	<time datetime="2017-03-09T14:17:26.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-03-09</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/杂记/">杂记</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-慕课程序与算法设计-二" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/15/慕课程序与算法设计-二/">慕课程序与算法设计(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><pre><code>基于逐个尝试答案的一种问题求解策略
</code></pre><h3 id="例题1-完美立方"><a href="#例题1-完美立方" class="headerlink" title="例题1 完美立方"></a>例题1 完美立方</h3><pre><code>#include &lt;iostream&gt;  
using namespace std;  

int main()  
{  
    int N;
    cin&gt;&gt;N;
    for(int a=2;a&lt;=N;a++){
        for(int b=2;b&lt;a-1;b++){
            for(int c=b;c&lt;a-1;c++){
                for(int d=c;d&lt;a-1;d++){
                    if(a*a*a==(b*b*b+c*c*c+d*d*d))
                        cout&lt;&lt;&quot;Cube = &quot;&lt;&lt;a&lt;&lt;&quot;,Triple = (&quot;&lt;&lt;b&lt;&lt;&quot;,&quot;&lt;&lt;c&lt;&lt;&quot;,&quot;&lt;&lt;d&lt;&lt;&quot;)&quot;&lt;&lt;endl; 
                }
            }
        }
    } 
    return 0;
}
</code></pre><h3 id="例题2-生理周期"><a href="#例题2-生理周期" class="headerlink" title="例题2 生理周期"></a>例题2 生理周期</h3><pre><code>#include &lt;iostream&gt;  
#include &lt;cstdio&gt;
using namespace std;  
#define N 21252
int main()  
{  
    //体力 情感 智力高峰出现的日子
    // d是给定的日子 
    //caseNo表示第几组测试用例 
    int p,e,i,d,caseNo=0;
    while(cin&gt;&gt;p&gt;&gt;e&gt;&gt;i&gt;&gt;d&amp;&amp;p!=-1){
        caseNo++;
        int k;
        for(k=d+1;(k-p)%23;k++);
        for(;(k-e)%28;k+=23);
        for(;(k-i)%33;k+=23*28);
        cout&lt;&lt;&quot;Case &quot;&lt;&lt;caseNo&lt;&lt;
            &quot;:the next triple peak occurs in &quot;&lt;&lt;
            k-d&lt;&lt;&quot;days.&quot;&lt;&lt;endl; 
    }
    return 0;
}
</code></pre><h3 id="POJ103称硬币"><a href="#POJ103称硬币" class="headerlink" title="POJ103称硬币"></a>POJ103称硬币</h3><p>思路：对于每一枚硬币先假设它是轻的，看这样是否符合称量结果。如果符合，则问题解决。如果不符合，则假设它是重的，看是否符合称量结果。把所有硬币都试一遍，一定能找到特殊硬币。</p>
<h2 id="递归-一"><a href="#递归-一" class="headerlink" title="递归(一)"></a>递归(一)</h2><pre><code>递归的作用：
1. 替代多重循环
2. 解决本来就是用递归形式定义的问题
3. 将问题分解为更小规模的子问题进行求解
</code></pre><h3 id="例题1-求阶乘"><a href="#例题1-求阶乘" class="headerlink" title="例题1 求阶乘"></a>例题1 求阶乘</h3><pre><code>#include &lt;iostream&gt;  
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt; 
#include &lt;algorithm&gt;
using namespace std;  
int Factorial(int n){
    if(n==0)
        return 1;
    else
        return n*Factorial(n-1); 
} 
int main()  
{  
    int n;
    cin&gt;&gt;n;
    cout&lt;&lt;Factorial(n)&lt;&lt;endl;
    return 0;
}
</code></pre><h3 id="例题2-汉诺塔问题"><a href="#例题2-汉诺塔问题" class="headerlink" title="例题2 汉诺塔问题"></a>例题2 汉诺塔问题</h3><pre><code>#include &lt;iostream&gt;  
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt; 
#include &lt;algorithm&gt;
using namespace std;  
void Hanoi(int n,char src,char mid , char dest){
    if(n==1){//只需移动一个盘子 
        cout&lt;&lt;src&lt;&lt;&quot;-&gt;&quot;&lt;&lt;dest&lt;&lt;endl;
        //直接将盘子从src移动到dest即可
        return;//递归终止 
    }
    Hanoi(n-1,src,dest,mid);//先将n-1个盘子从src移动到mid
    cout&lt;&lt;src&lt;&lt;&quot;-&gt;&quot;&lt;&lt;dest&lt;&lt;endl;
    //再将一个盘子从src移动到dest 
    Hanoi(n-1,mid,src,dest);//最后将n-1个盘子移动到dest
    return; 

}
int main()  
{  
    int n;
    cin&gt;&gt;n;
    Hanoi(n,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;); 
    return 0;
}
</code></pre><h3 id="例题3-N皇后问题"><a href="#例题3-N皇后问题" class="headerlink" title="例题3 N皇后问题"></a>例题3 N皇后问题</h3><h3 id="例题4-逆波兰表达式求值"><a href="#例题4-逆波兰表达式求值" class="headerlink" title="例题4 逆波兰表达式求值"></a>例题4 逆波兰表达式求值</h3><p>逆波兰表达式的定义：</p>
<ol>
<li>一个数是逆波兰表达式，值为该数</li>
<li>“运算符 逆波兰表达式 逆波兰表达式 ”是逆波兰表达式，值为两个逆波兰表达式的值的运算结果</li>
</ol>
<pre><code>#include &lt;iostream&gt;  
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt; 
#include &lt;algorithm&gt;
using namespace std;  

double exp(){
    char s[20];
    cin&gt;&gt;s;
    switch(s[0]){
        case &apos;+&apos;: return exp()+exp();break;
        case &apos;-&apos;: return exp()-exp();break;
        case &apos;*&apos;: return exp()*exp();break;
        case &apos;/&apos;: return exp()/exp();break;
        default: return atof(s);break;
        //atof 头文件 &lt;cstdlib&gt; 将字符串浮点数转化为double 
    }
}
int main()  
{  
    printf(&quot;%lf&quot;,exp()); 
    return 0;
}
</code></pre><h2 id="递归-二"><a href="#递归-二" class="headerlink" title="递归(二)"></a>递归(二)</h2><h3 id="例题1-表达式求值"><a href="#例题1-表达式求值" class="headerlink" title="例题1 表达式求值"></a>例题1 表达式求值</h3><pre><code>#include &lt;iostream&gt;  
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt; 
using namespace std;  
int factor_value();//读入一个因子
int term_value();//读入一项
int expression_value();//读入表达式 
int main()  
{  
    cout&lt;&lt;expression_value()&lt;&lt;endl;
    return 0;
}
int expression_value(){
    int result=term_value();//求一项的值
    bool more=true;//还有没有其他项
    while(more){
        char op=cin.peek();//看第一个字符，不取走
        if(op==&apos;+&apos;||op==&apos;-&apos;){
            cin.get();//从输入中取走一个字符
            int value=term_value();//求出第二项的值
            if(op==&apos;+&apos;) result+=value;
            else result-=value; 
        } 
        else more=false;
    } 
    return result;
}
int term_value(){
    int result=factor_value();
    while(true){
        char op=cin.peek();
        if(op==&apos;*&apos;||op==&apos;/&apos;){
            cin.get();//去掉*号或者/除号
            int value=factor_value();
            if(op==&apos;*&apos;) 
                result*=value;
            else
                result/=value;
        }else{
            break;
        }
    }
    return result;
}
int factor_value(){//求一个因子的值 
    int result=0;
    char c=cin.peek();
    if(c==&apos;(&apos;){
        cin.get();
        result=expression_value();
        cin.get();
    }
    else{
        while(isdigit(c)){
            result=10*result+c-&apos;0&apos;;
            cin.get();
            c=cin.peek();
        }
    }
    return result;
}
</code></pre><h3 id="例题2-爬楼梯"><a href="#例题2-爬楼梯" class="headerlink" title="例题2 爬楼梯"></a>例题2 爬楼梯</h3><pre><code>#include &lt;iostream&gt;  
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt; 
using namespace std;  
int upstaris(int n){
    if(n==0)
        return 1;
    else if(n&lt;0)
        return 0;
    else 
        return upstaris(n-1)+upstaris(n-2);
}
int main()  
{  
    int n;
    while(cin&gt;&gt;n)
    {
        cout&lt;&lt;upstaris(n)&lt;&lt;endl; 
    }
    return 0;
}
</code></pre><h3 id="例题3-放苹果"><a href="#例题3-放苹果" class="headerlink" title="例题3 放苹果"></a>例题3 放苹果</h3><h3 id="例题4-算24"><a href="#例题4-算24" class="headerlink" title="例题4 算24"></a>例题4 算24</h3><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><h2 id="动态规划-一"><a href="#动态规划-一" class="headerlink" title="动态规划(一)"></a>动态规划(一)</h2><h3 id="例题1-数字三角形-1"><a href="#例题1-数字三角形-1" class="headerlink" title="例题1.数字三角形(1)"></a>例题1.数字三角形(1)</h3><p>数字三角形递归超时版本</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define MAX 101
using namespace std;

int D[MAX][MAX];
int n;
int MaxSum(int i,int j){
    if(i==n)
        return D[i][j];    
    int x=MaxSum(i+1,j);
    int y=MaxSum(i+1,j+1);
    return max(x,y)+D[i][j];
}
int main(){
    int i,j;
    cin&gt;&gt;n;
    for(i=1;i&lt;=n;i++)
        for（j=1;j&lt;=i;j++）
            cin&gt;&gt;D[i][j];
    cout&lt;&lt;MaxSum(1,1)&lt;&lt;endl;
    return 0;
}
</code></pre><p>数字三角形的记忆递归型动归程序：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define MAX 101
using namespace std;
int maxSum[MAX][MAX];
int D[MAX][MAX];
int n;
int MaxSum(int i,int j){
    if(maxSum[i][j]!=-1)
        return maxSum[i][j];
    if(i==n)
        maxSum[i][j]= D[i][j];
    else {
    int x=MaxSum(i+1,j);
    int y=MaxSum(i+1,j+1);
    maxSum[i][j]=max(x,y)+D[i][j];
    }    

    return maxSum[i][j];
}
int main(){
    int i,j;
    cin&gt;&gt;n;
    for(i=1;i&lt;=n;i++)
        for(j=1;j&lt;=i;j++){
            cin&gt;&gt;D[i][j];
            maxSum[i][j]=-1;
        }
    cout&lt;&lt;MaxSum(1,1)&lt;&lt;endl;
    return 0;
}
</code></pre><h3 id="例题1-数字三角形-2"><a href="#例题1-数字三角形-2" class="headerlink" title="例题1.数字三角形(2)"></a>例题1.数字三角形(2)</h3>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/02/15/慕课程序与算法设计-二/" class="archive-article-date">
  	<time datetime="2017-02-15T01:59:15.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-02-15</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 晨曦的葬歌
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/GitHub/" style="font-size: 12.5px;">GitHub</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Unity/" style="font-size: 17.5px;">Unity</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/博客搭建/" style="font-size: 10px;">博客搭建</a> <a href="/tags/基础/" style="font-size: 20px;">基础</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/杂记/" style="font-size: 10px;">杂记</a> <a href="/tags/目标/" style="font-size: 10px;">目标</a> <a href="/tags/算法/" style="font-size: 12.5px;">算法</a>
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">勇敢地做梦，并向着那个梦去奔跑！</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>